/*! For license information please see 502.efc28fad5fb2b06171a9.bundle-prod.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[502],{692:(e,t,n)=>{n.d(t,{o:()=>a,z:()=>s});class a{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,r=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=r-1-e.padInfo.top,d=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${d});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=d-1-e.padInfo.front,f=c-1-e.padInfo.top,x=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${x});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},29476:(e,t,n)=>{n.d(t,{w:()=>s});var a=n(88478);class s{constructor(e,t,n,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],a.Wap.assertAndGetBroadcastShape(e,t),a.Wap.assertAndGetBroadcastShape(e,n);let r="0.0";null!=s&&(a.Wap.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let l="1.0";null!=o&&(a.Wap.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${r};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}},87373:(e,t,n)=>{n.d(t,{x:()=>s});var a=n(88478);class s{constructor(e,t,n,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],a.Wap.assertAndGetBroadcastShape(e,t),a.Wap.assertAndGetBroadcastShape(e,n);let r="vec4(0.0)";null!=s&&(a.Wap.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(a.Wap.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${r};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}},21480:(e,t,n)=>{n.d(t,{S:()=>o,x:()=>s});var a=n(88478);const s={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class o{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=a.Wap.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}},84039:(e,t,n)=>{n.d(t,{D1:()=>o,t6:()=>i});var a=n(88478),s=n(16697);const o="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class i{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=a.Wap.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=(0,s.C9)(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}},14488:(e,t,n)=>{n.d(t,{E2:()=>l,my:()=>r});var a=n(88478),s=n(16697),o=n(21034),i=n(55156);const r="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class l{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a.Wap.assertAndGetBroadcastShape(t,n);const l=this.outputShape.length;this.enableShapeUniforms=(0,s.C9)(l);let u="";if(r)if(0===l||1===a.D5U.sizeFromShape(this.outputShape))u="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(u=`\n          ${(0,i.kW)(l)} coords = getOutputCoords();\n        `,1===l)this.enableShapeUniforms?u+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":u+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=(0,o.Ky)("coords",l);this.enableShapeUniforms?u+=`\n            bool nextRowOutOfBounds =\n              (${e[l-2]} + 1) >= outShape[${l} - 2];\n            bool nextColOutOfBounds =\n              (${e[l-1]} + 1) >= outShape[${l} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:u+=`\n            bool nextRowOutOfBounds =\n              (${e[l-2]} + 1) >= ${this.outputShape[l-2]};\n            bool nextColOutOfBounds =\n              (${e[l-1]} + 1) >= ${this.outputShape[l-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${u}\n\n        setOutput(result);\n      }\n    `}}},90740:(e,t,n)=>{n.d(t,{jl:()=>r,nd:()=>i});var a=n(88478);const s={},o={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function i(e,t){s[e]=t}function r(e,t){if(!(e in s)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete s[e]}),!1),(0,a.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(o.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",o)||n.getContext("experimental-webgl",o):n.getContext("webgl2",o)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;s[e]=n}const n=s[e];return null==n||n.isContextLost()?(delete s[e],r(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),s[e])}},90150:(e,t,n)=>{n.d(t,{v:()=>a});class a{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}},96521:(e,t,n)=>{n.d(t,{V:()=>a});class a{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}},82314:(e,t,n)=>{n.d(t,{V:()=>a});class a{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}},47494:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(88478);class s{constructor(e){this.outputShape=[],this.outputShape=a.Wap.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const a=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${a}));`)}const s=t.length,o=t[t.length-1];n.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}},47625:(e,t,n)=>{n.d(t,{R:()=>i});var a=n(88478),s=n(21034),o=n(55156);class i{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=a.Wap.computeOutShape(e,t);const n=this.outputShape,i=n.length,l=(0,o.kW)(i),u=(0,s.Ky)("coords",i),d=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map(((e,t)=>`T${t}`));const c=new Array(e.length-1);c[0]=e[0][t];for(let n=1;n<c.length;n++)c[n]=c[n-1]+e[n][t];const h=d[t],p=d.slice(-2),f=d.join();let x=`if (${h} < ${c[0]}) {\n        return getChannel(\n            getT0(${f}), vec2(${p.join()}));\n        }`;for(let e=1;e<c.length;e++){const t=c[e-1];x+=`\n        if (${h} < ${c[e]}  && ${h} >= ${c[e-1]}) {\n          return getChannel(\n            getT${e}(${r(d,h,t)}),\n            vec2(${r(p,h,t)}));\n        }`}const g=c.length,m=c[c.length-1];x+=`\n        return getChannel(\n          getT${g}(${r(d,h,m)}),\n          vec2(${r(p,h,m)}));`,this.userCode=`\n      float getValue(${d.map((e=>"int "+e))}) {\n        ${x}\n      }\n\n      void main() {\n        ${l} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${u}), 0., 0., 0.);\n\n        ${u[i-1]} = ${u[i-1]} + 1;\n        if (${u[i-1]} < ${n[i-1]}) {\n          result.g = getValue(${u});\n        }\n\n        ${u[i-2]} = ${u[i-2]} + 1;\n        if (${u[i-2]} < ${n[i-2]}) {\n          result.a = getValue(${u});\n        }\n\n        ${u[i-1]} = ${u[i-1]} - 1;\n        if (${u[i-2]} < ${n[i-2]} &&\n            ${u[i-1]} < ${n[i-1]}) {\n          result.b = getValue(${u});\n        }\n        setOutput(result);\n      }\n    `}}function r(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?`${e} - ${n}`:e)).join()}},90301:(e,t,n)=>{n.d(t,{FF:()=>o,Ng:()=>a,P2:()=>s,cc:()=>i});class a{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,o="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,r=n-1-e.padInfo.left,l=o?1:2,u=o?2:3,d=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${d}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class o{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class i{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,r=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${r}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},37428:(e,t,n)=>{n.d(t,{g:()=>s,u:()=>a});class a{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,r=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},18954:(e,t,n)=>{n.d(t,{I:()=>a,S:()=>s});class a{constructor(e,t=!1,n=null,a=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,r=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,g=x?1:2,m=x?2:3,C=x?3:1;let v="",y="";n&&(v=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const $=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${r}, ${l});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${C}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${m}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${x}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${x}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${x}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${x}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${y}\n        setOutput(result);\n      }\n    `}}class s{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,c=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${r};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},64364:(e,t,n)=>{n.d(t,{J:()=>s});var a=n(16697);class s{constructor(e,t=!1,n=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const i=e.filterHeight,r=e.filterWidth,l=e.outChannels/e.inChannels;let u="",d="";n&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,d="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${d}\n        setOutput(result);\n      }\n    `}}},92734:(e,t,n)=>{n.d(t,{i:()=>o});var a=n(88478),s=n(16697);class o{constructor(e,t=!1,n=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,s.C9)(this.outputShape.length);const r=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,h=c;let p="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)p+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;p+=`\n     for (int r = 0; r < ${d}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<c;e++)p+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;p+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(h+1)/2;t++){const n=2*t;if(p+=`\n           xC = xCCorner + ${n*u};\n           `,1===l){if(n<c&&(r%2==1?(p+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,p+=1===u&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):p+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<c)){const e=r%2==0?a.D5U.nearestLargerEven(u):u;u%2==0&&r%2==1||u%2!=0&&r%2!=1?(p+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,p+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):p+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<c&&(r%2==1?(p+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<c&&(p+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(p+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<c&&(p+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<c&&(p+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<c&&(p+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}p+="\n     }\n   ",p+="\n     }\n   ",p+="\n     }\n   ";let f="",x="";n&&(f=o?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,x="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${p}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${x}\n         setOutput(result);\n       }\n     `}}},31177:(e,t,n)=>{n.d(t,{f:()=>o});var a=n(88478),s=n(16697);class o{constructor(e,t=!1,n=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,s.C9)(this.outputShape.length);const r=e.outChannels/e.inChannels,l=e.padInfo.left,u=e.strideWidth,d=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,p=h;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<h;e++)f+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;f+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<h;e++)f+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(p+1)/2;e++){const t=2*e;if(f+=`\n          xC = xCCorner + ${t*d};\n          `,1===u){if(t<h&&(l%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,f+=1===d&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<h)){const e=l%2==0?a.D5U.nearestLargerEven(d):d;d%2==0&&l%2==1||d%2!=0&&l%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,f+=d>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):f+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<h&&(l%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<h&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<h&&(f+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<h&&(f+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<h&&(f+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let x="",g="";n&&(x=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${r};\n        int q = d2 - d1 * ${r};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}},65120:(e,t,n)=>{n.d(t,{A:()=>a});class a{constructor(e,t,n,a,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,r,l]=e,[u]=t,[d,c]=n;this.outputShape=[u,d,c,l];const h="bilinear"===a?1:0,[p,f]=[i-1+".0",r-1+".0"],[x,g,m]=d>1?[""+(i-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[C,v,y]=c>1?[""+(r-1)/(c-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${x});\n      const float width_ratio = float(${C});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${m};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${y};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}},30330:(e,t,n)=>{n.d(t,{Q:()=>a,Z:()=>o});var a,s=n(55156);!function(e){e.Prod="*",e.Sum="+"}(a||(a={}));class o{constructor(e,t,n,o){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const l=this.outputShape.length,u=this.op===a.Prod?"1.0":"0.0",d=n?u:`getX(${i(l,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",p="";n?(h=o?"end != "+(c-1):"end != 0",p=o?"end + 1":"end - 1"):(h=o?`end + pow2 < ${c}`:"end >= pow2",p=o?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${(0,s.kW)(l)} coords = getOutputCoords();\n        int end = ${r(l,"coords",this.op)};\n        float val = ${d};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${p};\n          ${r(l,"coords",this.op)} = idx;\n          val ${this.op}= getX(${i(l,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function i(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function r(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}},87033:(e,t,n)=>{n.d(t,{h:()=>a});class a{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}},76473:(e,t,n)=>{n.d(t,{L:()=>a});class a{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}},93008:(e,t,n)=>{n.d(t,{H:()=>a});class a{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:s,strideWidth:o,filterHeight:i,filterWidth:r,dilationHeight:l,dilationWidth:u}=e,{top:d,left:c}=a;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${d}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${r}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}},90615:(e,t,n)=>{n.d(t,{O:()=>a});class a{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${a}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}},67137:(e,t,n)=>{n.d(t,{o:()=>a});class a{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}},67079:(e,t,n)=>{n.d(t,{i:()=>a});class a{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},55795:(e,t,n)=>{n.d(t,{S:()=>s});var a=n(55156);class s{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=(0,a.kW)(this.rank),s=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let t=0;t<e.length;t++)2===t?a.push("index"):a.push(`${n[t]}`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}},78428:(e,t,n)=>{n.d(t,{i:()=>s});var a=n(55156);class s{constructor(e,t,n,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=n;const o=(0,a.kW)(n.length);let i="\n    int index;";for(let e=0;e<this.sliceDim;e++)i+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}},29610:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(88478);function s(){let e,t,n,s,o,i,r,l,u,d;return 2===(0,a.OBj)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",s="in",o="texture",i="outputColor",r="out vec4 outputColor;",l=(0,a.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",d="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",s="varying",o="texture2D",i="gl_FragColor",r="",l="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",d="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:s,texture2D:o,output:i,defineOutput:r,defineSpecialNaN:l,defineSpecialInf:u,defineRound:d}}},16697:(e,t,n)=>{n.d(t,{C9:()=>c,IJ:()=>i,Yv:()=>r,_s:()=>u,mi:()=>d});var a=n(88478),s=n(55156),o=n(91906);function i(e,t,n,i){const l=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),u=l.map((e=>e.shapeInfo)),d={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},c=s.Vm(l,d,t),h=(0,o.xc)(e.gl,c),p=e.createProgram(h);return(0,a.OBj)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:h,source:c,webGLProgram:p,inShapeInfos:u,outShapeInfo:d,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:h,source:c,webGLProgram:p,inShapeInfos:u,outShapeInfo:d},r(e,t,p))}function r(e,t,n){const s={},o={},i={},r=[];let l,u,d,c=null,h=null;h=e.getUniformLocation(n,"NAN",!1),1===(0,a.OBj)().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const p=!1;for(let a=0;a<t.variableNames.length;a++){const r=t.variableNames[a];s[r]=e.getUniformLocation(n,r,p),s[`offset${r}`]=e.getUniformLocation(n,`offset${r}`,p),t.enableShapeUniforms&&(o[`${r}Shape`]=e.getUniformLocation(n,`${r}Shape`,p),i[`${r}TexShape`]=e.getUniformLocation(n,`${r}TexShape`,p))}return t.enableShapeUniforms&&(l=e.getUniformLocation(n,"outShape",p),d=e.getUniformLocation(n,"outShapeStrides",p),u=e.getUniformLocation(n,"outTexShape",p)),t.customUniforms&&t.customUniforms.forEach(((t,a)=>{r[a]=e.getUniformLocation(n,t.name,p)})),{uniformLocations:s,customUniformLocations:r,infLoc:c,nanLoc:h,inShapesLocations:o,inTexShapesLocations:i,outShapeLocation:l,outShapeStridesLocation:d,outTexShapeLocation:u}}function l(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const s=e.logicalShape,o=t[n],i=o.shape;if(!a.D5U.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const r=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!a.D5U.arraysEqual(r,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${r} and ${l} must match`)}))}function u(e,t,n,o,i){t.program.enableShapeUniforms||(l(t.inShapeInfos,n),l([t.outShapeInfo],[o]));const r=o.texData.texture,u=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(r.texture,u[0],u[1]):e.setOutputMatrixTexture(r.texture,u[0],u[1]),e.setProgram(t.webGLProgram),1===(0,a.OBj)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,o)=>{const i=t.program.variableNames[o],r=t.uniformLocations[i],l=t.uniformLocations[`offset${i}`],u=t.inShapesLocations[`${i}Shape`],d=t.inTexShapesLocations[`${i}TexShape`];if(u){const{uniformShape:a}=s.Tt(t.program.packedInputs,n.shape,n.texData.texShape);switch(a.length){case 1:e.gl.uniform1iv(u,new Int32Array(a));break;case 2:e.gl.uniform2iv(u,new Int32Array(a));break;case 3:e.gl.uniform3iv(u,new Int32Array(a));break;case 4:e.gl.uniform4iv(u,new Int32Array(a))}}if(d&&e.gl.uniform2i(d,n.texData.texShape[0],n.texData.texShape[1]),null!=r)if(n.isUniform)if(a.D5U.sizeFromShape(n.shape)<2)e.gl.uniform1f(r,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=n.texData.slice&&null!=l&&e.gl.uniform1i(l,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,r,o)}));const d=t.outShapeLocation;if(d)switch(o.shape.length){case 1:e.gl.uniform1iv(d,new Int32Array(o.shape));break;case 2:e.gl.uniform2iv(d,new Int32Array(o.shape));break;case 3:e.gl.uniform3iv(d,new Int32Array(o.shape));break;case 4:e.gl.uniform4iv(d,new Int32Array(o.shape))}if(t.outShapeStridesLocation){const n=a.D5U.computeStrides(o.shape);switch(o.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&i&&t.program.customUniforms.forEach(((n,a)=>{const s=t.customUniformLocations[a],o=i[a];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,o)}})),e.executeProgram()}function d(e,t,n){let o="";t.concat(n).forEach((t=>{const i=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const r=t.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:d}=s.Tt(e.packedInputs,t.shape,r);let c="",h="",p="";if(1===u.length&&e.packedInputs){const e=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==u.length||e.packedInputs){if(u.length>2&&!e.packedInputs){const e=a.D5U.computeStrides(u);p=`${e[0]===r[1]}_${e[e.length-1]===r[1]}`}}else h=`${u[0]>1}_${u[1]>1}`;const f=t.shape.length,x=2===u.length&&a.D5U.arraysEqual(t.shape,r),g=1===a.D5U.sizeFromShape(t.shape),m=a.Wap.getBroadcastDims(t.shape,n.shape),C=!e.packedInputs&&f===n.shape.length&&a.D5U.arraysEqual(r,n.texData.texShape),v=e.packedInputs||u.length>2?"":`${r[0]>1}_${r[1]>1}`;o+=`${f}_${C}_${l?d:""}_${u.length}_${g}_${m}_${x}_${c}_${h}_${p}_${v}_${i}`}else{const e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${i}`}}));const i=e.userCode;let r=e.constructor.name;return r+="_"+o+"_"+i+`${(0,a.OBj)().getNumber("WEBGL_VERSION")}`,r}function c(e){return(0,a.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}},4328:(e,t,n)=>{n.d(t,{A8:()=>w,AD:()=>O,BQ:()=>g,Cs:()=>y,HC:()=>E,Hb:()=>u,Hc:()=>$,Jj:()=>r,NQ:()=>x,P1:()=>T,Qr:()=>R,T2:()=>h,Uk:()=>b,Y3:()=>l,cU:()=>C,ez:()=>I,gl:()=>m,hf:()=>v,iN:()=>f,m8:()=>p,q3:()=>c});var a=n(88478),s=n(29610),o=n(18378),i=n(91906);function r(e){const t=(0,s.A)(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return i.Jj(e,n)}function l(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return i.ED(e,t)}function u(e){const t=new Uint16Array([0,1,2,2,1,3]);return i.mZ(e,t)}function d(e,t,n,s,o,r){i.b6(t,n);const l=i.cU(e),u=e.TEXTURE_2D;return i.O7(e,(()=>e.bindTexture(u,l))),i.O7(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),i.O7(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),i.O7(e,(()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST))),i.O7(e,(()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,a.OBj)().getNumber("WEBGL_VERSION")?i.O7(e,(()=>e.texImage2D(u,0,s,t,n,0,o,r,null))):i.O7(e,(()=>e.texStorage2D(u,1,s,t,n))),i.O7(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:l,texShape:[n,t]}}function c(e){return e.internalFormatFloat}function h(e,t,n,a){const[s,i]=o.kk(t,n);return d(e,s,i,c(a),a.textureFormatFloat,e.FLOAT)}function p(e){return e.internalFormatHalfFloat}function f(e,t,n,a){const[s,i]=o.kk(t,n);return d(e,s,i,p(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function x(e){return e.downloadTextureFormat}function g(e,t,n,a){const[s,i]=o.kk(t,n);return d(e,s,i,x(a),e.RGBA,e.UNSIGNED_BYTE)}function m(e){return e.internalFormatPackedFloat}function C(e,t,n,a){const[s,i]=o.qe(t,n);return d(e,s,i,m(a),e.RGBA,e.FLOAT)}function v(e){return e.internalFormatPackedHalfFloat}function y(e,t,n,a){const[s,i]=o.qe(t,n);return d(e,s,i,v(a),e.RGBA,a.textureTypeHalfFloat)}function $(e,t,n){return i.O7(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),i.sb(e,t,"clipSpacePos",n,3,20,0)&&i.sb(e,t,"uv",n,2,20,12)}function b(e,t,n,s,o,r){let l,u,d;i.O7(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),o instanceof Uint8Array?(l=new Uint8Array(n*s*4),u=e.UNSIGNED_BYTE,d=e.RGBA):(l=new Float32Array(n*s*4),u=e.FLOAT,d=r.internalFormatPackedFloat),l.set(o),2===(0,a.OBj)().getNumber("WEBGL_VERSION")?i.O7(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,s,e.RGBA,u,l))):i.O7(e,(()=>e.texImage2D(e.TEXTURE_2D,0,d,n,s,0,e.RGBA,u,l))),i.O7(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function R(e,t,n){i.O7(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,a.OBj)().getNumber("WEBGL_VERSION")?i.O7(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):i.O7(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,a.OBj)().getNumber("WEBGL_VERSION")?i.O7(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):i.O7(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),i.O7(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function w(e,t,n,a){const s=e.createBuffer();i.O7(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const o=16*t*n;return i.O7(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),i.O7(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),i.O7(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}function I(e,t,n){const a=e,s=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,s),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),s}function E(e,t,n,a){const[s,r]=o.kk(t,n),l=new Uint8Array(o.yb(t*n,4));return i.O7(e,(()=>e.readPixels(0,0,s,r,a.downloadTextureFormat,e.UNSIGNED_BYTE,l))),new Float32Array(l.buffer)}function O(e,t,n,a,s,i,r,l){const u=e,d=new Float32Array(o.Se(i,r));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function T(e,t,n){const a=new Float32Array(t*n*4);return i.O7(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}},77129:(e,t,n)=>{n.d(t,{l:()=>o});var a=n(29610),s=n(16697);class o{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=(0,s.C9)(this.outputShape.length);const{dataFormat:n}=t,o=(0,a.A)(),i="channelsLast"===n,r=i?1:2,l=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let d="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)d+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${r}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${l}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${d}\n\n        ${o.output} = result;\n      }\n    `}}},38795:(e,t,n)=>{var a=n(88478),s=n(91906);const o=(0,a.OBj)();o.registerFlag("HAS_WEBGL",(()=>o.getNumber("WEBGL_VERSION")>0)),o.registerFlag("WEBGL_VERSION",(()=>(0,s.uH)(2)?2:(0,s.uH)(1)?1:0)),o.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),o.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===o.get("WEBGL_VERSION"))),o.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),o.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),o.registerFlag("WEBGL_PACK",(()=>o.getBool("HAS_WEBGL"))),o.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_CLIP",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_REDUCE",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_LAZILY_UNPACK",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_CONV_IM2COL",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>(0,s.lo)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>(0,s.KP)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=o.getNumber("WEBGL_VERSION");return 0===e?0:(0,s.nr)(e)})),o.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>o.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!a.C2$.isMobile())),o.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>(0,s.wb)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!o.getBool("WEBGL_FORCE_F16_TEXTURES")&&o.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),o.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>(0,s.BH)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>(0,s.Qd)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>o.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),o.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),o.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>a.C2$.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),o.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),o.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),o.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),o.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),o.registerFlag("WEBGL_EXP_CONV",(()=>!1)),o.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>o.getBool("IS_TEST"))),o.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),o.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),o.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),o.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var i=n(90740),r=n(29610),l=n(16697),u=n(38110),d=n(18378);class c{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=d.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=(0,r.A)();this.outputShape=e,this.enableShapeUniforms=(0,l.C9)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?u.Kn(["r","c","d"],e):u.RW(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class h{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=d.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=(0,r.A)();this.outputShape=e,this.enableShapeUniforms=(0,l.C9)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?u.Kn(["r","c","d"],e):u.RW(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class p{constructor(e){this.variableNames=["A"],this.outTexUsage=d.v2.DOWNLOAD;const t=(0,r.A)();this.outputShape=e,this.userCode=`\n      ${u.ye}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class f{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=d.v2.DOWNLOAD;const t=(0,r.A)();this.outputShape=e,this.userCode=`\n      ${u.ye}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const x={R:0,G:1,B:2,A:3};class g{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=(0,r.A)();this.outputShape=e,this.enableShapeUniforms=(0,l.C9)(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let o="";for(let e=0;e<n.length;e++){const t=n[e];o+=`\n          if(offset == ${e}) {\n            result = values[${x[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?u.nc():u.ku(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${a.texture2D}(A, uv);\n          ${o}\n        }\n        ${a.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class m{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=(0,r.A)();this.outputShape=e,this.enableShapeUniforms=(0,l.C9)(this.outputShape.length);let a="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const o=2*t+s;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?u.nc():u.ku(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${s};\n        }\n    `}}var C=n(4328);class v{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,a.OBj)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,(0,i.nd)(t,e)):this.gl=(0,i.jl)(t),e=this.gl,2===(0,a.OBj)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>s.O7(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>s.O7(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>s.O7(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>s.O7(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>s.O7(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>s.O7(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>s.O7(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>s.O7(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,a.OBj)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=s.HH(this.gl,e),s.y_(this.gl,t))this.textureHalfFloatExtension=s.HH(this.gl,t);else if((0,a.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),s.y_(this.gl,o))this.colorBufferHalfFloatExtension=s.HH(this.gl,o);else if((0,a.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",s.y_(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!s.y_(this.gl,o))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(o)}this.vertexBuffer=C.Y3(this.gl),this.indexBuffer=C.Hb(this.gl),this.framebuffer=s.d8(this.gl),this.textureConfig=d.Sq(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,a.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;s.O7(e,(()=>e.finish())),s.O7(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),s.O7(e,(()=>e.deleteFramebuffer(this.framebuffer))),s.O7(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),s.O7(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),s.O7(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),C.T2(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),C.iN(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),C.BQ(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),C.Qr(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),C.Uk(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),C.Cs(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),C.cU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(s.ax(this.gl,this.framebuffer),this.outputTexture=null),s.O7(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>C.HC(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,s,o){return C.AD(this.gl,e,t,n,a,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return C.ez(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=C.A8(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,a.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,s=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(s,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=s}else(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>C.P1(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=C.Jj(t));const n=s.HO(t);let a;return s.O7(t,(()=>t.attachShader(n,this.vertexShader))),s.O7(t,(()=>t.attachShader(n,e))),s.aj(t,n),a=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(a.vao),s.O7(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),console.assert(C.Hc(t,a,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&s.vu(t,a),this.setProgram(a),a}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(s.O7(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&s.vu(this.gl,this.program)),s.O7(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?s.XE(this.gl,e,t):s.Hg(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),s.O7(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),s.B(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,s]=d.qe(t,n);this.setOutputMatrixTextureDriver(e,a,s)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&s.vu(this.gl,this.program),s.cu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}s.O7(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),s.O7(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=s.HH(this.gl,2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await a.D5U.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in(0,a.OBj)().platform&&(n=(0,a.OBj)().platform.setTimeoutCustom.bind((0,a.OBj)().platform)),a.D5U.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),s.JG(this.gl,e,this.framebuffer),this.debug&&s.cu(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(s.JG(this.gl,this.outputTexture,this.framebuffer),this.debug&&s.cu(this.gl)):s.ax(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;s.JG(a,e,this.framebuffer),this.debug&&s.cu(a),this.outputTexture=e,s.O7(a,(()=>a.viewport(0,0,t,n))),s.O7(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),s.O7(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}var y=n(64272),$=n(55667),b=n(28831),R=n(42490),w=n(84518),I=n(29365),E=n(84595);const O=a.GDt.ZA,T={},S=(0,a.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class _ extends a.Zuw{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,a.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof v)t=e;else{const n=(0,i.jl)((0,a.OBj)().getNumber("WEBGL_VERSION"),e);t=new v(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=(0,i.jl)((0,a.OBj)().getNumber("WEBGL_VERSION"));t=new v(e),this.binaryCache=((n=(0,a.OBj)().getNumber("WEBGL_VERSION"))in T||(T[n]={}),T[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new R.I(this.gpgpu),this.numMBBeforeWarning=null==(0,a.OBj)().global.screen?1024:(0,a.OBj)().global.screen.height*(0,a.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new a.JLz(this,(0,a.SRH)())}nextDataId(){return _.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,o,i){const r=this.makeTensorInfo(t,n),l=this.texData.get(r.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[a,o]},l.texShape=[a,o];const u=s.ih(t),d=new g(u,!1,i),c=this.runWebGLProgram(d,[r],n,[[a,o]]);return c.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(r),c.dataId}write(e,t,n){if(((0,a.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,a.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:d.v2.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,s,o){if((0,a.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:d.v2.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:o,slice:i,shape:r,isPacked:l}=t;if(null!=i){let t;t=l?new I.cc(r,w.bl):new w.l(r,w.bl);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const u=null!=this.activeTimers;let d,c;if(u&&(d=a.D5U.now()),"complex64"===s){const e=this.readSync(o.real.dataId),t=this.readSync(o.imag.dataId);c=a.Wap.mergeRealAndImagArrays(e,t)}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=a.D5U.now()-d),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:o,slice:i,dtype:r,complexTensorInfos:l,isPacked:u}=t;if(null!=i){let t;t=u?new I.cc(o,w.bl):new w.l(o,w.bl);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,a.OBj)().getBool("DEBUG")&&!(0,a.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,a.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,h,p=null;if("complex64"!==r&&(0,a.OBj)().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);p=this.gpgpu.createBufferFromTexture(t.texture.texture,...d.Yz(o))}if(this.pendingRead.set(e,[]),"complex64"!==r&&await this.gpgpu.createAndWaitForFence(),"complex64"===r){const e=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),t=e[0],n=e[1];h=a.Wap.mergeRealAndImagArrays(t,n)}else if(null==p)h=this.getValuesFromTexture(e);else{const e=a.D5U.sizeFromShape(o);h=this.gpgpu.downloadFloat32MatrixFromBuffer(p,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=p){const e=this.gpgpu.gl;s.O7(e,(()=>e.deleteBuffer(p)))}const f=this.convertAndCacheOnCPU(e,h),x=this.pendingRead.get(e);return this.pendingRead.delete(e),x.forEach((e=>e(f))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,a.SRH)().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const n=this.texData.get(e),{values:s,shape:o,slice:i,dtype:r,isPacked:l,texture:u}=n;if("complex64"===r)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=l?new I.cc(o,w.bl):new w.l(o,w.bl);const a=this.runWebGLProgram(n,[{dataId:e,shape:o,dtype:r}],r),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==u)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),c=(0,a.SRH)().makeTensorFromTensorInfo(d),h=this.texData.get(d.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>a.D5U.decodeString(e)));return(0,a.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.f3b)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!s.qF(n)){if((0,a.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:o}=this.texData.get(e),i=a.D5U.sizeFromShape(t);if((0,a.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...d.Yz(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),s}const r=(0,a.OBj)().getBool("WEBGL_PACK")&&!0===o,l=r?s.ih(t):t,u=r?new f(l):new p(l),c=this.runWebGLProgram(u,[{shape:l,dtype:n,dataId:e}],"float32"),h=this.texData.get(c.dataId),x=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),x}timerAvailable(){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=a.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=a.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const r={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);r.kernelMs=a.D5U.sum(e),r.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else r.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,r})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.D5U.now(),endMs:null}}endTimer(e){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=a.D5U.now(),e)}async getQueryTime(e){if((0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:o,slice:i}=this.texData.get(e),r=i&&i.origDataId||e,l=this.dataRefCount.get(r);l>1?this.dataRefCount.set(r,l-1):(this.dataRefCount.delete(r),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=S){return(0,a.OBj)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&a.D5U.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){a.Wap.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return O(e.shape,t)}packedUnaryOp(e,t,n){const s=new I.cc(e.shape,t),o=this.compileAndRun(s,[e],n);return(0,a.SRH)().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=(0,y.CJ)(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,a.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,w.Et,e.dtype);const t=new w.l(e.shape,w.Et),n=this.compileAndRun(t,[e]);return(0,a.SRH)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&a.D5U.isString(n[0])){const o=n.map((e=>a.D5U.encodeString(e)));s=this.write(o,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){return(0,a.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new E.W(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new $.U(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[s.Cp(e.shape),...s.W8(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},o=[s.Cp(t),...s.W8(t)],i=new b.v(o,n),r=[n],l=this.runWebGLProgram(i,[a],e.dtype,r,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:o,shape:i,dtype:r}=n;if(null!=t){const e=a.D5U.sizeFromShape(i),n=t[0]*t[1]*4;a.D5U.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const l=s.ih(i);let u;u=o?new h(l):new c(l);const p=[null!=t?t:d.Yz(l)];return{dtype:r,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:r,dataId:e}],r,p,!0,t).dataId}}runWebGLProgram(e,t,n,o,i=!1,r){const u=this.makeTensorInfo(e.outputShape,n),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===d.m1.DENSE){const t=null!=r?r:d.Yz(e.outputShape);c.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===a.D5U.sizeFromShape(u.shape))return c.values=a.D5U.getTypedArrayFromDType(u.dtype,0),u;const h=[],p=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&a.D5U.sizeFromShape(t.shape)<=(0,a.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),h.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!s.oT(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),h.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(u.dataId);const f={shape:u.shape,texData:c,isUniform:!1},x=l.mi(e,p,f),g=this.getAndSaveBinary(x,(()=>l.IJ(this.gpgpu,e,p,f))),m=null!=this.activeTimers;let C;m&&(C=this.startTimer()),(0,a.OBj)().get("ENGINE_COMPILE_ONLY")||l._s(this.gpgpu,g,p,f,o),h.forEach((e=>this.disposeIntermediateTensorInfo(e))),m&&(C=this.endTimer(C),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(C)}));const v=(0,a.OBj)().get("WEBGL_FLUSH_THRESHOLD");if(v>0){const e=a.D5U.now();e-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,a.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===i){const e=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),e}return u}compileAndRun(e,t,n,a,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,a,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,a.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,a.lub)((()=>{if(!(0,a.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,a.OBj)().getBool("DEBUG");(0,a.OBj)().set("DEBUG",!1);const t=this.abs((0,a.iD$)(1e-8)).dataSync()[0];if((0,a.OBj)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:o,values:i,texture:r,usage:l,isPacked:u}=t;if(null!=r)return;const c=null!=this.activeTimers;let h;c&&(h=a.D5U.now());let p=t.texShape;if(null==p&&(p=s.Yf(n,u),t.texShape=p),null!=i){const e=s.ih(n);let r,l=p[1],f=p[0];const x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;!u&&x||([l,f]=d.qe(p[0],p[1])),r=u?new m(e,x):new g(e,x);const C=x?[f,l]:p,v=this.makeTensorInfo(C,o),y=this.texData.get(v.dataId);y.usage=x?d.v2.PIXELS:d.v2.UPLOAD,y.texShape=C,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),l,f,i);const $=[[f,l]],b=!0,R=this.runWebGLProgram(r,[v],o,$,b),w=this.texData.get(R.dataId);t.texShape=w.texShape,t.isPacked=w.isPacked,t.usage=w.usage,(0,a.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(t.texture=w.texture,t.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=a.D5U.now()-h)}else{const e=this.acquireTexture(p,l,o,u);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*a.D5U.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,a.glt)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw s.w4(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,inShapesLocations:o,inTexShapesLocations:i,outShapeLocation:r,outShapeStridesLocation:u,outTexShapeLocation:d}=(0,l.Yv)(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.inShapesLocations=o,e.inTexShapesLocations=i,e.outShapeLocation=r,e.outShapeStridesLocation=u,e.outTexShapeLocation=d}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:r}=e,l=(0,a.SRH)().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,t,n,o,i,r);return(0,a.SRH)().makeTensorFromDataId(u,t,n,l)}}_.nextDataId=0;var A=n(25522);a.C2$.isBrowser()&&(0,a.jqO)("webgl",(()=>new _),2),A.kS,n(19665)},77121:(e,t,n)=>{n.d(t,{J:()=>c});var a=n(88478);class s{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const i="max"===t?">":"<",r=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${r};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}var o=n(21034),i=n(55156);class r{constructor(e,t,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,a.D5U.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],l=Math.ceil(r/t);this.outputShape=e.slice(0,-1),l>1&&this.outputShape.push(l),s||this.variableNames.push("bestIndicesA");const u=this.outputShape,d=u.length,c=(0,i.kW)(d),h=(0,o.Ky)("coords",d);let p,f;if(1===l){f=d+1;const e=(0,i.kW)(f);p=`\n        ${e} sourceLocR = ${e}(${h.join()}, 0);\n        ++${h[d-1]};\n        ${e} sourceLocG = ${e}(${h.join()}, 0);\n        ++${h[d-2]};\n        ${e} sourceLocA = ${e}(${h.join()}, 0);\n        --${h[d-1]};\n        ${e} sourceLocB = ${e}(${h.join()}, 0);\n        --${h[d-2]};`}else f=d,p=`\n        ${c} sourceLocR = coords;\n        ++${h[d-1]};\n        ${c} sourceLocG = coords;\n        ++${h[d-2]};\n        ${c} sourceLocA = coords;\n        --${h[d-1]};\n        ${c} sourceLocB = coords;\n        --${h[d-2]};`;const x=["x","y","z","w","u","v"].slice(0,f),g="."+x[f-1],m=x.map((e=>"int "+e)),C=(0,o.Ky)("sourceLocR",f-1).concat("inIdx.r"),v=(0,o.Ky)("sourceLocG",f-1).concat("inIdx.g"),y=(0,o.Ky)("sourceLocB",f-1).concat("inIdx.b"),$=(0,o.Ky)("sourceLocA",f-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",R=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${$.join()})));`,w=`vec4(\n            getAChannel(${C.join()}),\n            hasNextCol ? getAChannel(${v.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,I=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${I}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${h[d-1]} < ${u[d-1]-1};\n        bool hasNextRow = ${h[d-2]} < ${u[d-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},\n          sourceLocB${g}, sourceLocA${g}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${R}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}var l=n(24622);function u(e,t,n,o=null){let i=t.shape[0],r=t.shape[1];null!=o&&(i=o.shape[0],r=o.shape[1]);const l=a.Wap.computeOptimalWindowSize(r),d={windowSize:l,inSize:r,batchSize:i,outSize:Math.ceil(r/l)},c=new s(d,n,null==o),h=[t];null!=o&&h.push(o);const p=e.runWebGLProgram(c,h,"int32");if(1===p.shape[1])return p;const f=u(e,t,n,p);return e.disposeIntermediateTensorInfo(p),f}function d(e,t,n,s=null){const o=null!=s?s.shape:t.shape,i=o[o.length-1],l=a.Wap.computeOptimalWindowSize(i),u=new r(o,l,n,null==s),c=null==s?[t]:[t,s],h=e.runWebGLProgram(u,c,"int32");if(h.shape.length===t.shape.length){const a=d(e,t,n,h);return e.disposeIntermediateTensorInfo(h),a}return h}function c(e,t,n,s){const o=[n];if(a.Wap.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),o,t.shape.length),!(0,a.OBj)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],i=e.texData.get(t.dataId);let r=t;null!==i&&i.isPacked&&(r=e.unpackTensor(t),n.push(r));const[d,c]=a.Wap.computeOutAndReduceShapes(r.shape,o),h=a.D5U.sizeFromShape(c),p=(0,l.X)({inputs:{x:r},backend:e,attrs:{shape:[-1,h]}});n.push(p);const f=u(e,p,s);n.push(f);const x=(0,l.X)({inputs:{x:f},backend:e,attrs:{shape:d}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),x}return d(e,t,s)}},22842:(e,t,n)=>{n.d(t,{e:()=>s});var a=n(84518);function s(e,t){const n=new a.l(e.shape,"return float(int(x));"),s=t.runWebGLProgram(n,[e],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}},15367:(e,t,n)=>{n.d(t,{AJ:()=>h,E6:()=>c,g8:()=>f,js:()=>p});var a=n(88478),s=n(84039),o=n(14488),i=n(56515),r=n(1736),l=n(73525),u=n(84518),d=n(29365);const c="if (isnan(x)) return x;";function h({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:o,backend:i})=>{const{x:r}=o,l=i,c=s||r.dtype;if(l.shouldExecuteOnCPU([r])&&null!=n){const e=l.texData.get(r.dataId),t=n(e.values,c);return l.makeTensorInfo(r.shape,c,t)}let h;return h=(0,a.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new d.cc(r.shape,t):new u.l(r.shape,e),l.runWebGLProgram(h,[r],c)}}function p({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:l,dtype:u}){return({inputs:d,backend:c})=>{const{a:h,b:p}=d,f=c;if(r&&"complex64"===h.dtype){const t=f.texData.get(h.dataId),n=f.texData.get(p.dataId),[o,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,o]=t,i={dataId:n.dataId,dtype:n.dtype,shape:h.shape},r={dataId:o.dataId,dtype:o.dtype,shape:p.shape},l=new s.t6(e,h.shape,p.shape);return f.runWebGLProgram(l,[i,r],(0,a.x8V)(n.dtype,o.dtype))})),l=(0,i.P)({inputs:{real:o,imag:r},backend:f});return f.disposeIntermediateTensorInfo(o),f.disposeIntermediateTensorInfo(r),l}const x=u||(0,a.x8V)(h.dtype,p.dtype);if(("string"===h.dtype||"string"===p.dtype||f.shouldExecuteOnCPU([h,p]))&&null!=l){const e=f.texData.get(h.dataId).values,t=f.texData.get(p.dataId).values,n="string"===h.dtype?a.Wap.fromUint8ToStringArray(e):e,s="string"===h.dtype?a.Wap.fromUint8ToStringArray(t):t,[o,i]=l(h.shape,p.shape,n,s,x),r=f.makeTensorInfo(i,x);return f.texData.get(r.dataId).values=o,r}let g;return g=(0,a.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new o.E2(t,h.shape,p.shape,n):new s.t6(e,h.shape,p.shape),f.runWebGLProgram(g,[h,p],x)}}function f(e,t=!1){if("linear"===e)return t?d.t$:u.t$;if("relu"===e)return t?d.RX:u.RX;if("elu"===e)return t?d.Cv:u.Cv;if("relu6"===e)return t?d.eW:u.eW;if("prelu"===e)return t?l.VO:l.pU;if("leakyrelu"===e)return t?r.s4:r.oA;if("sigmoid"===e)return t?d.Tq:u.Tq;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}},98259:(e,t,n)=>{n.d(t,{u:()=>i});var a=n(88478),s=n(13315),o=n(24196);function i(e,t,n,i){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],s=a.Wap.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}(e.shape);let l=e;for(let a=0;a<r.length;a++){const{inSize:u,windowSize:d,outSize:c}=r[a];let h,p;h="mean"===n?0===a?new s.h({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},u):new s.h({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c}):new o.f({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},n),p=l,l=i.runWebGLProgram(h,[l],t),p.dataId!==e.dataId&&i.disposeIntermediateTensorInfo(p)}return l}},5314:(e,t,n)=>{n.d(t,{V:()=>o});var a=n(28831),s=n(91906);function o(e,t,n){const o=[(0,s.Cp)(e.shape),...(0,s.W8)(e.shape)],i={dtype:e.dtype,shape:o,dataId:e.dataId},r=[(0,s.Cp)(t),...(0,s.W8)(t)],l=new a.v(r,o),u=[o],d=n.runWebGLProgram(l,[i],e.dtype,u,!0);return{dataId:d.dataId,shape:t,dtype:d.dtype}}},64272:(e,t,n)=>{n.d(t,{$O:()=>b,$j:()=>M,$u:()=>V,A0:()=>X,AR:()=>k,B_:()=>g,Bk:()=>G,Bo:()=>E,CJ:()=>P,CV:()=>K,Fv:()=>Y,KX:()=>H,LS:()=>U,M8:()=>_,MZ:()=>p,PQ:()=>y,Qs:()=>S,Rn:()=>v,Sd:()=>$,St:()=>B,TD:()=>f,Tg:()=>T,Th:()=>I,UN:()=>L,X8:()=>F,Y1:()=>N,_9:()=>z,aX:()=>c,cK:()=>s,cZ:()=>O,cm:()=>r,cx:()=>i,fy:()=>A,gv:()=>d,hO:()=>D,ji:()=>m,kI:()=>j,kY:()=>C,m$:()=>x,n7:()=>u,nL:()=>R,nT:()=>W,oC:()=>Q,pk:()=>l,qO:()=>o,r:()=>w,tx:()=>h});var a=n(1221);const{addImpl:s,bincountImpl:o,bincountReduceImpl:i,castImpl:r,ceilImpl:l,concatImpl:u,equalImpl:d,expImpl:c,expm1Impl:h,floorImpl:p,gatherNdImpl:f,gatherV2Impl:x,greaterImpl:g,greaterEqualImpl:m,lessImpl:C,lessEqualImpl:v,linSpaceImpl:y,logImpl:$,maxImpl:b,maximumImpl:R,minimumImpl:w,multiplyImpl:I,negImpl:E,notEqualImpl:O,prodImpl:T,raggedGatherImpl:S,raggedRangeImpl:_,raggedTensorToTensorImpl:A,rangeImpl:D,rsqrtImpl:B,scatterImpl:N,sigmoidImpl:L,simpleAbsImpl:P,sliceImpl:W,sparseFillEmptyRowsImpl:F,sparseReshapeImpl:U,sparseSegmentReductionImpl:k,sqrtImpl:G,stridedSliceImpl:V,stringNGramsImpl:M,stringSplitImpl:X,stringToHashBucketFastImpl:z,subImpl:j,tileImpl:H,topKImpl:Q,transposeImpl:Y,uniqueImpl:K}=a},55512:(e,t,n)=>{n.d(t,{f:()=>l});var a=n(88478),s=n(64272),o=n(84518),i=n(29365);const r="return abs(x);",l={kernelName:a.SYM,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:l}=t;if(n.shouldExecuteOnCPU([l])&&"complex64"!==l.dtype){const e=n.texData.get(l.dataId),t=(0,s.CJ)(e.values);return n.makeTensorInfo(l.shape,l.dtype,t)}let u;return u=(0,a.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new i.cc(l.shape,r):new o.l(l.shape,r),n.runWebGLProgram(u,[l],l.dtype)}}},4998:(e,t,n)=>{n.d(t,{r:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.VGw,backendName:"webgl",kernelFunc:i}},98200:(e,t,n)=>{n.d(t,{v:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.SpW,backendName:"webgl",kernelFunc:i}},77763:(e,t,n)=>{n.d(t,{j:()=>l});var a=n(88478),s=n(15367),o=n(64272);const i="return a + b;",r=(0,s.js)({opSnippet:i,packedOpSnippet:i,supportsComplex:!0,cpuKernelImpl:o.cK}),l={kernelName:a.mm_,backendName:"webgl",kernelFunc:r}},54309:(e,t,n)=>{n.d(t,{_:()=>r});var a=n(88478);class s{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}class o{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}var i=n(18955);const r={kernelName:a.Xze,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,l=n;if(1===l.length)return(0,i.y)({inputs:{x:l[0]},backend:r});if(l.length>(0,a.OBj)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(l.length/2),n=e({inputs:l.slice(0,t),backend:r}),a=e({inputs:l.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const u=l.map((e=>e.dtype)).reduce(((e,t)=>(0,a.x8V)(e,t))),d=l.map((e=>e.shape)),c=(0,a.OBj)().getBool("WEBGL_PACK")?new o(l[0].shape,d):new s(l[0].shape,d);return r.runWebGLProgram(c,l,u)}}},67923:(e,t,n)=>{n.d(t,{O:()=>r});var a=n(88478),s=n(98259),o=n(24622),i=n(72207);const r={kernelName:a.oT6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:l}=t,{axis:u,keepDims:d}=r,c=l.shape.length,h=a.D5U.parseAxisParam(u,l.shape);let p=h;const f=a.Wap.getAxesPermutation(p,c);let x=l;null!=f&&(x=(0,i.p)({inputs:{x:l},backend:n,attrs:{perm:f}}),p=a.Wap.getInnerMostAxes(p.length,c)),a.Wap.assertAxesAreInnerMostDims("all",p,c);const[g,m]=a.Wap.computeOutAndReduceShapes(x.shape,p),C=a.D5U.sizeFromShape(m),v=(0,o.X)({inputs:{x},backend:n,attrs:{shape:[-1,C]}}),y=(0,s.u)(v,v.dtype,"all",n);let $;if(d){const e=a.Wap.expandShapeToKeepDim(g,h);$=(0,o.X)({inputs:{x:y},backend:n,attrs:{shape:e}})}else $=(0,o.X)({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),null!=f&&n.disposeIntermediateTensorInfo(x),$}}},48344:(e,t,n)=>{n.d(t,{H:()=>r});var a=n(88478),s=n(98259),o=n(24622),i=n(72207);const r={kernelName:a.IKK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:l}=t,{axis:u,keepDims:d}=r,c=l.shape.length,h=a.D5U.parseAxisParam(u,l.shape);let p=h;const f=a.Wap.getAxesPermutation(p,c);let x=l;null!=f&&(x=(0,i.p)({inputs:{x:l},backend:n,attrs:{perm:f}}),p=a.Wap.getInnerMostAxes(p.length,c)),a.Wap.assertAxesAreInnerMostDims("any",p,c);const[g,m]=a.Wap.computeOutAndReduceShapes(x.shape,p),C=a.D5U.sizeFromShape(m),v=(0,o.X)({inputs:{x},backend:n,attrs:{shape:[-1,C]}}),y=(0,s.u)(v,v.dtype,"any",n);let $;if(d){const e=a.Wap.expandShapeToKeepDim(g,h);$=(0,o.X)({inputs:{x:y},backend:n,attrs:{shape:e}})}else $=(0,o.X)({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),null!=f&&n.disposeIntermediateTensorInfo(x),$}}},79646:(e,t,n)=>{n.d(t,{d:()=>i});var a=n(88478),s=n(77121),o=n(72207);const i={kernelName:a.sJF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:r}=t,{axis:l}=i;let u=a.D5U.parseAxisParam(l,r.shape);const d=a.Wap.getAxesPermutation(u,r.shape.length);let c=r;const h=[];null!=d&&(c=(0,o.p)({inputs:{x:r},backend:n,attrs:{perm:d}}),h.push(c),u=a.Wap.getInnerMostAxes(u.length,c.shape.length)),a.Wap.assertAxesAreInnerMostDims("argMax",[u[0]],c.shape.length);const p=(0,s.J)(n,c,u[0],"max");return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}}},44612:(e,t,n)=>{n.d(t,{O:()=>i});var a=n(88478),s=n(77121),o=n(72207);const i={kernelName:a.aJk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:r}=t,{axis:l}=i;let u=a.D5U.parseAxisParam(l,r.shape);const d=a.Wap.getAxesPermutation(u,r.shape.length);let c=r;const h=[];null!=d&&(c=(0,o.p)({inputs:{x:r},backend:n,attrs:{perm:d}}),h.push(c),u=a.Wap.getInnerMostAxes(u.length,c.shape.length)),a.Wap.assertAxesAreInnerMostDims("argMin",[u[0]],c.shape.length);const p=(0,s.J)(n,c,u[0],"min");return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}}},58088:(e,t,n)=>{n.d(t,{h:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.M2y,backendName:"webgl",kernelFunc:i}},56604:(e,t,n)=>{n.d(t,{W:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"return log(x + sqrt(x * x + 1.0));",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.qw7,backendName:"webgl",kernelFunc:i}},76505:(e,t,n)=>{n.d(t,{E:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"\n  return atan(x);\n",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.jMg,backendName:"webgl",kernelFunc:i}},47729:(e,t,n)=>{n.d(t,{t:()=>d});var a=n(88478),s=n(84039),o=n(14488),i=n(15367);const r=s.D1+"\n  return atan(a, b);\n",l="\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+o.my+"\n  return result;\n",u=(0,i.js)({opSnippet:r,packedOpSnippet:l}),d={kernelName:a.QCc,backendName:"webgl",kernelFunc:u}},69179:(e,t,n)=>{n.d(t,{B:()=>r});var a=n(88478),s=n(15367);const o=n(84518).D1+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",i=(0,s.AJ)({opSnippet:o}),r={kernelName:a.Oyi,backendName:"webgl",kernelFunc:i}},38731:(e,t,n)=>{n.d(t,{U:()=>r});var a=n(88478),s=n(90789),o=n(91906),i=n(18955);const r={kernelName:a.JhU,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:l}=t;(0,o.HS)(l,"avgPool");const{filterSize:u,strides:d,pad:c,dimRoundingMode:h}=r;a.D5U.assert(a.Wap.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const p=a.Wap.computePool2DInfo(l.shape,u,d,1,c,h);if(1===p.filterWidth&&1===p.filterHeight&&a.D5U.arraysEqual(p.inShape,p.outShape))return(0,i.y)({inputs:{x:l},backend:n});const f=new s.n(p,"avg",!1);return n.runWebGLProgram(f,[l],"float32")}}},27878:(e,t,n)=>{n.d(t,{z:()=>o});var a=n(88478),s=n(90789);const o={kernelName:a._k9,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:i}=t,{filterSize:r,strides:l,pad:u,dimRoundingMode:d,dataFormat:c}=o,h=a.Wap.computePool3DInfo(i.shape,r,l,[1,1,1],u,d,c),p=new s.I(h,"avg",!1);return n.runWebGLProgram(p,[i],"float32")}}},71230:(e,t,n)=>{n.d(t,{Y:()=>o});var a=n(88478),s=n(692);const o={kernelName:a.IMb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:i,input:r}=t,l=r,{filterSize:u,strides:d,pad:c,dimRoundingMode:h}=o,p=a.Wap.computePool3DInfo(l.shape,u,d,[1,1,1],c,h),f=new s.z(p);return n.runWebGLProgram(f,[i],l.dtype)}}},48717:(e,t,n)=>{n.d(t,{v:()=>i});var a=n(88478),s=n(692),o=n(91906);const i={kernelName:a.ROF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{dy:r,input:l}=t,u=l;(0,o.HS)([r,l],"avgPoolGrad");const{filterSize:d,strides:c,pad:h}=i,p=a.Wap.computePool2DInfo(u.shape,d,c,1,h),f=new s.o(p);return n.runWebGLProgram(f,[r],u.dtype)}}}}]);