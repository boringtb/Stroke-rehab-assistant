/*! For license information please see 482.a6cd27642832b8390bf3.bundle-prod.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[482],{40588:(t,e,i)=>{i.d(e,{LH:()=>s,j1:()=>n,nj:()=>a,nu:()=>r,ps:()=>o});class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}}class s extends Error{constructor(t){super(t),Object.setPrototypeOf(this,s.prototype)}}class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}}class a extends Error{constructor(t){super(t),Object.setPrototypeOf(this,a.prototype)}}class o extends Error{constructor(t){super(t),Object.setPrototypeOf(this,o.prototype)}}class l extends Error{constructor(t){super(t),Object.setPrototypeOf(this,l.prototype)}}},93202:(t,e,i)=>{i.d(e,{FB:()=>f});var n=i(88478),s=i(64843);(0,n.OBj)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),s.kS),i(88940);var r=i(64079),a=i(85654),o=i(34396),l=i(20163),h=(i(28891),i(5540)),u=i(79608),c=i(40588),p=i(49897),d=i(2931),g=i(51977),m=i(87538);async function f(t,e){if(null==e&&(e={}),"string"==typeof t){const i=n.io.getLoadHandlers(t,e);if(0===i.length)i.push(n.io.browserHTTPRequest(t,e));else if(i.length>1)throw new c.nu(`Found more than one (${i.length}) load handlers for URL '${t}'`);t=i[0]}return async function(t,e,i){if(null==i&&(i={}),null==t.load)throw new c.nu("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await t.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const a=null==i.strict||i.strict,o=null!=s.weightData&&null!=s.weightSpecs&&a,l=(0,p.v)((0,g.a)(r),void 0,o),h=s.trainingConfig;if(null!=h&&l.loadTrainingConfig(h),null!=s.userDefinedMetadata&&l.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new c.nu("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const i=n.io.decodeWeights(t,e),s={},r=[];return e.forEach((t=>{"optimizer"===t.group?r.push({name:t.name,tensor:i[t.name]}):s[t.name]=i[t.name]})),{modelWeights:s,optimizerWeights:r}}(s.weightData,s.weightSpecs);l.loadWeights(t,a),null!=l.optimizer&&e.length>0&&await l.optimizer.setWeights(e),(0,n.B90)(t),(0,n.B90)(e.map((t=>t.tensor)))}return l}(t,0,e)}class y extends h.QV{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:(0,u.s)("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new c.nu(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof y||t instanceof h.QV;let i;if(e){if(i=t,1!==i.outputs.length)throw new c.nu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new c.nu("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new c.nu("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=(0,o.I)({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==t.inboundNodes.length)throw new c.nu(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new c.nu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=(0,l.hA)(this.outputs[0])}this.inboundNodes=[],new l.NB({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:d.JE(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if((0,m.Wf)(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new h.QV({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,i=console.log){this.built||this.build(),super.summary(t,e,i)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,i={}){if(!this.built)throw new c.LH("The model needs to be compiled before being used.");return this.model.evaluate(t,e,i)}async evaluateDataset(t,e){if(!this.built)throw new c.LH("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,i={}){if(!this.built)throw new c.LH("The model needs to be compiled before being used.");return this.model.fit(t,e,i)}async fitDataset(t,e){if(!this.built)throw new c.LH("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,i={},s=!1){let r,a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new c.nu("Legacy serialization format not supported yet.");r=e}else n.D5U.assert(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=e.layers,delete e.layers,a=e;const o=new t(a);if(!(o instanceof y))throw new c.nj(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const t of r){const e=void 0,i=(0,p.v)(t,e,s);s&&i.setFastWeightInitDuringBuild(!0),o.add(i)}return o}set stopTraining(t){if(null==this.model)throw new c.nu("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new c.nu("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const i={};i.className=e.getClassName(),i.config=e.getConfig(),t.push(i)}return{name:this.name,layers:t}}}y.className="Sequential",n.m7h.registerClass(y);var b=i(28819),C=i(39840);class S extends n.m7h.Serializable{}class v extends S{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return(0,n.lub)((()=>{let e=(0,n.lls)([1]);return this.hasL1&&(e=(0,n.IHx)(e,(0,n.Smz)(n.dC7(this.l1,(0,n.WnP)(t))))),this.hasL2&&(e=(0,n.IHx)(e,(0,n.Smz)(n.dC7(this.l2,C.h6(t))))),n.XLQ(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}v.className="L1L2",n.m7h.registerClass(v);const w={l1l2:"L1L2"};function k(t){return(0,d.Kj)(t)}function R(t,e={}){return(0,d.tU)(t,n.m7h.SerializationMap.getMap().classNameMap,e,"regularizer")}function T(t){return null==t?null:"string"==typeof t?R({className:t in w?w[t]:t,config:{}}):t instanceof S?t:R(t)}class z extends l.mh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=(0,m.nQ)(t);let i=(0,n.UYe)(t);return null!=this.maxValue&&(i=(0,n.iUl)(i,0,this.maxValue)),i}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}z.className="ReLU",n.m7h.registerClass(z);class I extends l.mh{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const i=(0,m.nQ)(t);return(0,n.hi7)(i,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}I.className="LeakyReLU",n.m7h.registerClass(I);class A extends l.mh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=(0,a.L5)(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=T(t.alphaRegularizer),this.alphaConstraint=(0,r.Ad)(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new c.nu(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=(0,m.Wf)(t)).slice(1);if(null!=this.sharedAxes)for(const t of this.sharedAxes)e[t-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let e=1;e<t.length;++e)i[e]=t[e];this.inputSpec=[new l.Zg({ndim:t.length,axes:i})],this.built=!0}call(t,e){return t=(0,m.nQ)(t),(0,n.AL3)(t,this.alpha.read())}getConfig(){const t={alphaInitializer:(0,a.Cx)(this.alphaInitializer),alphaRegularizer:k(this.alphaRegularizer),alphaConstraint:(0,r.xF)(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}A.className="PReLU",n.m7h.registerClass(A);class x extends l.mh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new c.nj(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const i=(0,m.nQ)(t);return(0,n.pyx)(i)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}x.className="ELU",n.m7h.registerClass(x);class N extends l.mh{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const i=(0,m.nQ)(t);return(0,n.dC7)(i,(0,n.pju)((0,n.pjt)(i,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}N.className="ThresholdedReLU",n.m7h.registerClass(N);class D extends l.mh{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new b.Gc).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const i=(0,m.nQ)(t);return this.softmax(i,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}D.className="Softmax",n.m7h.registerClass(D);var E=i(12012),L=i(48090),_=i(96040);function F(t,e,i){if("number"==typeof t)return(0,d.JE)(t,e);if(t.length!==e)throw new c.nu(`The ${i} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let n=0;n<e;++n){const s=t[n];if(!(0,_.U)(s))throw new c.nu(`The ${i} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function O(t,e,i,n,s=1){if(null==t)return t;let r;return r="same"===i?t:t-(e+(e-1)*(s-1))+1,Math.floor((r+n-1)/n)}function M(t,e,i,n){if(null==t)return null;if("valid"===n)t=t*e+(0,_.Fp)([i-e,0]);else{if("same"!==n)throw new c.nu(`Unsupport padding mode: ${n}.`);t*=e}return t}function P(t,e){return(0,n.lub)((()=>((0,L.cj)(e),"channelsFirst"===e?n.p4s(t,[0,2,3,1]):t)))}function j(t,e){return(0,n.lub)((()=>((0,L.cj)(e),"channelsFirst"===e?n.p4s(t,[0,2,3,4,1]):t)))}function U(t,e,i,s=[1,1],r="valid",a,o,l=null){return(0,n.lub)((()=>{if(null==a&&(a=(0,E.rf)()),(0,L.cj)(a),3!==t.rank&&4!==t.rank)throw new c.nu(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new c.nu(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let h=P(t,a);if("causal"===r)throw new c.nj("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return h=n.imm.conv2d({x:h,filter:e,strides:s,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:i,activation:l}),"channelsFirst"===a&&(h=n.p4s(h,[0,3,1,2])),h}))}class W extends l.mh{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",W.verifyArgs(e),this.rank=t,d.iQ(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new c.nj(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=F(e.kernelSize,t,"kernelSize"),this.strides=F(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,(0,L.zb)(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,(0,L.cj)(this.dataFormat),this.activation=(0,b.aI)(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=(0,a.L5)(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=(0,r.Ad)(e.biasConstraint),this.biasRegularizer=T(e.biasRegularizer),this.activityRegularizer=T(e.activityRegularizer),this.dilationRate=F(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new c.nu(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new c.nu(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new c.nu(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(d.hu("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!d.Mx(t.kernelSize,"number",1,3))throw new c.nu(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:(0,b.GD)(this.activation),useBias:this.useBias,biasInitializer:(0,a.Cx)(this.biasInitializer),biasRegularizer:k(this.biasRegularizer),activityRegularizer:k(this.activityRegularizer),biasConstraint:(0,r.xF)(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class $ extends W{constructor(t,e){super(t,e),this.kernel=null,$.verifyArgs(e),this.filters=e.filters,d.iQ(this.filters,"filters"),this.kernelInitializer=(0,a.L5)(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=(0,r.Ad)(e.kernelConstraint),this.kernelRegularizer=T(e.kernelRegularizer)}build(t){t=(0,m.Wf)(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new c.nu(`The channel dimension of the input should be defined. Found ${t[e]}`);const i=t[e],n=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",n,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:i}}],this.built=!0}call(t,e){return(0,n.lub)((()=>{let e;t=(0,m.nQ)(t);const i=null==this.bias?null:this.bias.read(),s=d.WT(this.activation.getClassName());if(null!=s&&2===this.rank)e=U(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,i,s=1,r="valid",a,o=1){return(0,n.lub)((()=>{if(null==a&&(a=(0,E.rf)()),(0,L.cj)(a),3!==t.shape.length)throw new c.nu(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new c.nu(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=i&&1!==i.shape.length)throw new c.nu(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===a&&(t=n.p4s(t,[0,2,1])),"causal"===r)throw new c.nj("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=n.PAt(t,e,s,"same"===r?"same":"valid","NWC",o);return null!=i&&(l=C.a2(l,i)),l}))}(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=U(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new c.nj("convolutions greater than 3D are not implemented yet.");e=function(t,e,i,s=[1,1,1],r="valid",a,o){return(0,n.lub)((()=>{if(null==a&&(a=(0,E.rf)()),(0,L.cj)(a),4!==t.rank&&5!==t.rank)throw new c.nu(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new c.nu(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let l=j(t,a);if("causal"===r)throw new c.nj("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=n.pdZ(l,e,s,"same"===r?"same":"valid","NDHWC",o),null!=i&&(l=C.a2(l,i)),"channelsFirst"===a&&(l=n.p4s(l,[0,4,1,2,3])),l}))}(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=(0,m.Wf)(t);const e=[],i="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<i.length;++t){const n=O(i[t],this.kernelSize[t],this.padding,this.strides[t],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[t]);e.push(n)}let n=[t[0]];return"channelsLast"===this.dataFormat?(n=n.concat(e),n.push(this.filters)):(n.push(this.filters),n=n.concat(e)),n}getConfig(){const t={filters:this.filters,kernelInitializer:(0,a.Cx)(this.kernelInitializer),kernelRegularizer:k(this.kernelRegularizer),kernelConstraint:(0,r.xF)(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new c.nu(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class B extends ${constructor(t){super(2,t),B.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!d.Mx(t.kernelSize,"number",1,2))throw new c.nu(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}B.className="Conv2D",n.m7h.registerClass(B);class H extends ${constructor(t){super(3,t),H.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new c.nu(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}H.className="Conv3D",n.m7h.registerClass(H);class Q extends B{constructor(t){if(super(t),this.inputSpec=[new l.Zg({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new c.nu(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=(0,m.Wf)(t)).length)throw new c.nu("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new c.nu("The channel dimension of the inputs should be defined. Found `None`.");const i=t[e],n=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new l.Zg({ndim:4,axes:{[e]:i}})],this.built=!0}call(t,e){return n.lub((()=>{let e=(0,m.nQ)(t);if(4!==e.shape.length)throw new c.nu(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const i=e.shape,s=i[0];let r,a;"channelsFirst"===this.dataFormat?(r=2,a=3):(r=1,a=2);const o=i[r],l=i[a],h=this.kernelSize[0],u=this.kernelSize[1],p=this.strides[0],d=this.strides[1],g=[s,M(o,p,h,this.padding),M(l,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=n.p4s(e,[0,2,3,1]));let f=n.bc(e,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(f=n.p4s(f,[0,3,1,2])),null!=this.bias&&(f=C.a2(f,this.bias.read(),this.dataFormat)),null!=this.activation&&(f=this.activation.apply(f)),f}))}computeOutputShape(t){const e=(t=(0,m.Wf)(t)).slice();let i,n,s;"channelsFirst"===this.dataFormat?(i=1,n=2,s=3):(i=3,n=1,s=2);const r=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[i]=this.filters,e[n]=M(e[n],o,r,this.padding),e[s]=M(e[s],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Q.className="Conv2DTranspose",n.m7h.registerClass(Q);class J extends H{constructor(t){if(super(t),this.inputSpec=[new l.Zg({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new c.nu(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=(0,m.Wf)(t)).length)throw new c.nu("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new c.nu("The channel dimension of the inputs should be defined. Found `None`.");const i=t[e],n=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new l.Zg({ndim:5,axes:{[e]:i}})],this.built=!0}call(t,e){return n.lub((()=>{let e=(0,m.nQ)(t);if(5!==e.shape.length)throw new c.nu(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const i=e.shape,s=i[0];let r,a,o;"channelsFirst"===this.dataFormat?(o=2,r=3,a=4):(o=1,r=2,a=3);const l=i[o],h=i[r],u=i[a],p=this.kernelSize[0],d=this.kernelSize[1],g=this.kernelSize[2],f=this.strides[0],y=this.strides[1],b=this.strides[2],S=[s,M(l,f,p,this.padding),M(h,y,d,this.padding),M(u,b,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=n.p4s(e,[0,2,3,4,1]));let v=n.$QV(e,this.kernel.read(),S,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=n.p4s(v,[0,4,1,2,3])),null!==this.bias&&(v=C.a2(v,this.bias.read(),this.dataFormat)),null!==this.activation&&(v=this.activation.apply(v)),v}))}computeOutputShape(t){const e=(t=(0,m.Wf)(t)).slice();let i,n,s,r;"channelsFirst"===this.dataFormat?(i=1,n=2,s=3,r=4):(i=4,n=1,s=2,r=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],h=this.strides[0],u=this.strides[1],c=this.strides[2];return e[i]=this.filters,e[n]=M(e[n],h,a,this.padding),e[s]=M(e[s],u,o,this.padding),e[r]=M(e[r],c,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}J.className="Conv3DTranspose",n.m7h.registerClass(J);class V extends ${constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new c.nu("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new c.nu("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new c.nu(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=(0,a.L5)(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=T(e.depthwiseRegularizer),this.depthwiseConstraint=(0,r.Ad)(e.depthwiseConstraint),this.pointwiseInitializer=(0,a.L5)(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=T(e.pointwiseRegularizer),this.pointwiseConstraint=(0,r.Ad)(e.pointwiseConstraint)}build(t){if((t=(0,m.Wf)(t)).length<this.rank+2)throw new c.nu(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new c.nu(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const i=t[e],n=this.kernelSize.concat([i,this.depthMultiplier]),s=[];for(let t=0;t<this.rank;++t)s.push(1);s.push(i*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",n,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new l.Zg({ndim:this.rank+2,axes:{[e]:i}})],this.built=!0}call(t,e){return(0,n.lub)((()=>{let e;if(t=(0,m.nQ)(t),1===this.rank)throw new c.nj("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=n.p4s(t,[0,2,3,1])),e=n.U_I(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=C.a2(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=n.p4s(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=(0,a.Cx)(this.depthwiseInitializer),t.pointwiseInitializer=(0,a.Cx)(this.pointwiseInitializer),t.depthwiseRegularizer=k(this.depthwiseRegularizer),t.pointwiseRegularizer=k(this.pointwiseRegularizer),t.depthwiseConstraint=(0,r.xF)(this.depthwiseConstraint),t.pointwiseConstraint=(0,r.xF)(this.pointwiseConstraint),t}}V.className="SeparableConv";class G extends V{constructor(t){super(2,t)}}G.className="SeparableConv2D",n.m7h.registerClass(G);class Z extends ${constructor(t){super(1,t),Z.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!d.Mx(t.kernelSize,"number",1,1))throw new c.nu(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Z.className="Conv1D",n.m7h.registerClass(Z);class q extends l.mh{constructor(t){super(t),"number"==typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return(0,n.lub)((()=>{if(t=(0,m.nQ)(t),"channelsLast"===this.dataFormat){const e=C.uI(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return C.uI(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=C.uI(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return C.uI(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}q.className="Cropping2D",n.m7h.registerClass(q);class K extends l.mh{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,(0,L.cj)(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,(0,L.wU)(this.interpolation)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],i=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,i]}{const e=null==t[1]?null:this.size[0]*t[1],i=null==t[2]?null:this.size[1]*t[2];return[t[0],e,i,t[3]]}}call(t,e){return n.lub((()=>{let e=(0,m.nQ)(t);const i=e.shape;if("channelsFirst"===this.dataFormat){e=n.p4s(e,[0,2,3,1]);const t=this.size[0]*i[2],s=this.size[1]*i[3],r="nearest"===this.interpolation?n.BHj.resizeNearestNeighbor(e,[t,s]):n.BHj.resizeBilinear(e,[t,s]);return n.p4s(r,[0,3,1,2])}{const t=this.size[0]*i[1],s=this.size[1]*i[2];return"nearest"===this.interpolation?n.BHj.resizeNearestNeighbor(e,[t,s]):n.BHj.resizeBilinear(e,[t,s])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}K.className="UpSampling2D",n.m7h.registerClass(K);class X extends W{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=(0,a.L5)(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=(0,r.Ad)(t.depthwiseConstraint),this.depthwiseRegularizer=T(t.depthwiseRegularizer)}build(t){if((t=(0,m.Wf)(t)).length<4)throw new c.nu(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new c.nu(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const i=t[e],n=[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",n,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return(0,n.lub)((()=>{let e=function(t,e,i=[1,1],s="valid",r,a){return(0,n.lub)((()=>{null==r&&(r=(0,E.rf)()),(0,L.cj)(r);let o=P(t,r);if(4!==t.rank)throw new c.nu(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new c.nu(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=n.B10(o,e,i,"same"===s?"same":"valid","NHWC",a),"channelsFirst"===r&&(o=n.p4s(o,[0,3,1,2])),o}))}(t=(0,m.nQ)(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=C.a2(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=(0,m.Wf)(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=O(e,this.kernelSize[0],this.padding,this.strides[0]),r=O(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,s,r]:[t[0],s,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=(0,a.Cx)(this.depthwiseInitializer),t.depthwiseRegularizer=k(this.depthwiseRegularizer),t.depthwiseConstraint=(0,r.xF)(this.depthwiseRegularizer),t}}X.className="DepthwiseConv2D",n.m7h.registerClass(X);var Y=i(41653);function tt(t,e,i,n){if(Array.isArray(t)){if(null!=e||null!=i)throw new c.nu("When inputs is an array, neither initialState or constants should be provided");null!=n&&(i=t.slice(t.length-n,t.length),t=t.slice(0,t.length-n)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=s(e),constants:i=s(i)}}function et(t,e,i,s=!1,r,a,o=!1,l=!1){return n.lub((()=>{const h=e.shape.length;if(h<3)throw new c.nu(`Input should be at least 3D, but is ${h}D.`);const u=[1,0].concat(_.w6(2,h));if(e=n.p4s(e,u),null!=a)throw new c.nj("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=n.pju(n.pju(r,"bool"),"float32")).rank===h-1&&(r=n.dt4(r,-1)),r=n.p4s(r,u)),s&&(e=n.GYS(e,0),null!=r&&(r=n.GYS(r,0)));const p=[];let d,g=i;const m=e.shape[0],f=n.HHK(e);let y,b;null!=r&&(y=n.HHK(r));for(let e=0;e<m;++e){const i=f[e],s=n.lub((()=>t(i,g)));if(null==r)d=s[0],g=s[1];else{const t=n.lub((()=>{const t=y[e],i=n.luU(n.JpU(t),t),r=n.IHx(n.dC7(s[0],t),n.dC7(g[0],i)),a=g.map(((e,r)=>n.IHx(n.dC7(s[1][r],t),n.dC7(e,i))));return{output:r,newStates:a}}));d=t.output,g=t.newStates}l&&p.push(d)}if(l){const t=1;b=n.knu(p,t)}return[d,b,g]}))}class it extends l.mh{constructor(t){let e;if(super(t),null==t.cell)throw new c.nu("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new ut({cells:t.cell}):t.cell,null==e.stateSize)throw new c.nu("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new l.Zg({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return _.w6(0,t).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){(0,m.XO)(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const i=e[0];let n;if(n=this.returnSequences?[t[0],t[1],i]:[t[0],i],this.returnState){const i=[];for(const n of e)i.push([t[0],n]);return[n].concat(i)}return n}computeMask(t,e){return n.lub((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let i=0;i<t;++i)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new c.nj("Constants support is not implemented in RNN yet.");(0,m.XO)(t)&&(t=t[0]);const e=this.stateful?t[0]:null,i=t.slice(2);this.inputSpec[0]=new l.Zg({shape:[e,null,...i]});const s=[t[0]].concat(t.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!n.D5U.arraysEqual(this.stateSpec.map((t=>t.shape[t.shape.length-1])),r))throw new c.nu(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((t=>new l.Zg({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t,e=!1){(0,n.lub)((()=>{if(!this.stateful)throw new c.j1("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new c.nu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>n.lls([i,t]))):this.states_=[n.lls([i,this.cell.stateSize])];else if(null==t)n.B90(this.states_),null!=this.keptStates&&(n.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>n.lls([i,t]))):this.states_[0]=n.lls([i,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new c.nu(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):n.B90(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,a=[i,r];if(!n.D5U.arraysEqual(s.shape,a))throw new c.nu(`State ${e} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map((t=>n.CnY(t.clone())))}))}apply(t,e){let i=null==e?null:e.initialState,n=null==e?null:e.constants;null==e&&(e={});const s=tt(t,i,n,this.numConstants);t=s.inputs,i=s.initialState,n=s.constants;let r=[],a=[];if(null!=i){e.initialState=i,r=r.concat(i),this.stateSpec=[];for(const t of i)this.stateSpec.push(new l.Zg({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=n&&(e.constants=n,r=r.concat(n),this.numConstants=n.length),r[0]instanceof l.Iy){const i=[t].concat(r),n=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=n;const o=super.apply(i,e);return this.inputSpec=s,o}return super.apply(t,e)}call(t,e){return(0,n.lub)((()=>{const i=null==e?null:e.mask,n=null==e?null:e.training;let s=null==e?null:e.initialState;t=(0,m.nQ)(t),null==s&&(s=this.stateful?this.states_:this.getInitialState(t));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==r)throw new c.nu(`RNN Layer has ${r} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:n},o=et(((t,e)=>{const i=this.cell.call([t].concat(e),a);return[i[0],i.slice(1)]}),t,s,this.goBackwards,i,null,this.unroll,this.returnSequences),l=o[0],h=o[1],u=o[2];this.stateful&&this.resetStates(u,n);const p=this.returnSequences?h:l;return this.returnState?[p].concat(u):p}))}getInitialState(t){return(0,n.lub)((()=>{let e=n.lls(t.shape);return e=n.Smz(e,[1,2]),e=C.dt(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?C.Gg(e,[1,t]):e)):this.cell.stateSize>1?[C.Gg(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===it.className&&(e.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),t),e)}static fromConfig(t,e,i={}){const n=e.cell,s=(0,p.v)(n,i);return new t(Object.assign(e,{cell:s}))}}it.className="RNN",n.m7h.registerClass(it);class nt extends l.mh{}class st extends nt{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,(0,d.iQ)(this.units,"units"),this.activation=(0,b.aI)(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,a.L5)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,a.L5)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,a.L5)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=T(t.kernelRegularizer),this.recurrentRegularizer=T(t.recurrentRegularizer),this.biasRegularizer=T(t.biasRegularizer),this.kernelConstraint=(0,r.Ad)(t.kernelConstraint),this.recurrentConstraint=(0,r.Ad)(t.recurrentConstraint),this.biasConstraint=(0,r.Ad)(t.biasConstraint),this.dropout=_.VV([1,_.Fp([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=_.VV([1,_.Fp([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=(0,m.Wf)(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return(0,n.lub)((()=>{if(2!==t.length)throw new c.nu(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let i=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ct({ones:()=>n.JpU(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ct({ones:()=>n.JpU(i),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;r=null!=a?C.AK(n.dC7(t,a),this.kernel.read()):C.AK(t,this.kernel.read()),null!=this.bias&&(r=C.a2(r,this.bias.read())),null!=o&&(i=n.dC7(i,o));let l=n.IHx(r,C.AK(i,this.recurrentKernel.read()));return null!=this.activation&&(l=this.activation.apply(l)),[l,l]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,b.GD)(this.activation),useBias:this.useBias,kernelInitializer:(0,a.Cx)(this.kernelInitializer),recurrentInitializer:(0,a.Cx)(this.recurrentInitializer),biasInitializer:(0,a.Cx)(this.biasInitializer),kernelRegularizer:k(this.kernelRegularizer),recurrentRegularizer:k(this.recurrentRegularizer),biasRegularizer:k(this.biasRegularizer),activityRegularizer:k(this.activityRegularizer),kernelConstraint:(0,r.xF)(this.kernelConstraint),recurrentConstraint:(0,r.xF)(this.recurrentConstraint),biasConstraint:(0,r.xF)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}st.className="SimpleRNNCell",n.m7h.registerClass(st);class rt extends it{constructor(t){t.cell=new st(t),super(t)}call(t,e){return(0,n.lub)((()=>{null!=this.cell.dropoutMask&&(n.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(n.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return new t(e)}}rt.className="SimpleRNN",n.m7h.registerClass(rt);class at extends nt{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new c.nu("GRUCell does not support reset_after parameter set to true.");this.units=t.units,(0,d.iQ)(this.units,"units"),this.activation=(0,b.aI)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=(0,b.aI)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,a.L5)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,a.L5)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,a.L5)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=T(t.kernelRegularizer),this.recurrentRegularizer=T(t.recurrentRegularizer),this.biasRegularizer=T(t.biasRegularizer),this.kernelConstraint=(0,r.Ad)(t.kernelConstraint),this.recurrentConstraint=(0,r.Ad)(t.recurrentConstraint),this.biasConstraint=(0,r.Ad)(t.biasConstraint),this.dropout=_.VV([1,_.Fp([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=_.VV([1,_.Fp([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=(0,m.Wf)(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return(0,n.lub)((()=>{if(2!==t.length)throw new c.nu(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const i=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ct({ones:()=>n.JpU(t),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ct({ones:()=>n.JpU(s),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,h;0<this.dropout&&this.dropout<1&&(t=n.dC7(t,r[0]));let u=C.AK(t,this.kernel.read());this.useBias&&(u=C.a2(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=n.dC7(s,a[0]));const p=this.recurrentKernel.read(),[d,g]=n.Vl2(p,[2*this.units,this.units],p.rank-1),m=C.AK(s,d),[f,y,b]=n.Vl2(u,3,u.rank-1),[S,v]=n.Vl2(m,2,m.rank-1);o=this.recurrentActivation.apply(n.IHx(f,S)),l=this.recurrentActivation.apply(n.IHx(y,v));const w=C.AK(n.dC7(l,s),g);h=this.activation.apply(n.IHx(b,w));const k=n.IHx(n.dC7(o,s),n.dC7(n.IHx(1,n.W76(o)),h));return[k,k]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,b.GD)(this.activation),recurrentActivation:(0,b.GD)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:(0,a.Cx)(this.kernelInitializer),recurrentInitializer:(0,a.Cx)(this.recurrentInitializer),biasInitializer:(0,a.Cx)(this.biasInitializer),kernelRegularizer:k(this.kernelRegularizer),recurrentRegularizer:k(this.recurrentRegularizer),biasRegularizer:k(this.biasRegularizer),activityRegularizer:k(this.activityRegularizer),kernelConstraint:(0,r.xF)(this.kernelConstraint),recurrentConstraint:(0,r.xF)(this.recurrentConstraint),biasConstraint:(0,r.xF)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}at.className="GRUCell",n.m7h.registerClass(at);class ot extends it{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new at(t),super(t)}call(t,e){return(0,n.lub)((()=>{null!=this.cell.dropoutMask&&(n.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(n.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}ot.className="GRU",n.m7h.registerClass(ot);class lt extends nt{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,(0,d.iQ)(this.units,"units"),this.activation=(0,b.aI)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=(0,b.aI)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,a.L5)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,a.L5)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,a.L5)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=T(t.kernelRegularizer),this.recurrentRegularizer=T(t.recurrentRegularizer),this.biasRegularizer=T(t.biasRegularizer),this.kernelConstraint=(0,r.Ad)(t.kernelConstraint),this.recurrentConstraint=(0,r.Ad)(t.recurrentConstraint),this.biasConstraint=(0,r.Ad)(t.biasConstraint),this.dropout=_.VV([1,_.Fp([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=_.VV([1,_.Fp([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const i=(t=(0,m.Wf)(t))[t.length-1];let n;if(this.kernel=this.addWeight("kernel",[i,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,i=this.units;n=new((e=class extends a.m7{apply(e,n){const s=t.apply([i]),r=(new a.M6).apply([i]),o=t.apply([2*i]);return C.GZ(C.GZ(s,r),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return(0,n.lub)((()=>{const i=null!=e.training&&e.training;if(3!==t.length)throw new c.nu(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ct({ones:()=>n.JpU(t),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ct({ones:()=>n.JpU(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,h,u,p;0<this.dropout&&this.dropout<1&&(t=n.dC7(t,a[0]));let d=C.AK(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=n.dC7(s,o[0])),d=n.IHx(d,C.AK(s,this.recurrentKernel.read())),this.useBias&&(d=C.a2(d,this.bias.read()));const[g,m,f,y]=n.Vl2(d,4,d.rank-1);l=this.recurrentActivation.apply(g),h=this.recurrentActivation.apply(m),u=n.IHx(n.dC7(h,r),n.dC7(l,this.activation.apply(f))),p=this.recurrentActivation.apply(y);const b=n.dC7(p,this.activation.apply(u));return[b,b,u]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,b.GD)(this.activation),recurrentActivation:(0,b.GD)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:(0,a.Cx)(this.kernelInitializer),recurrentInitializer:(0,a.Cx)(this.recurrentInitializer),biasInitializer:(0,a.Cx)(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:k(this.kernelRegularizer),recurrentRegularizer:k(this.recurrentRegularizer),biasRegularizer:k(this.biasRegularizer),activityRegularizer:k(this.activityRegularizer),kernelConstraint:(0,r.xF)(this.kernelConstraint),recurrentConstraint:(0,r.xF)(this.recurrentConstraint),biasConstraint:(0,r.xF)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}lt.className="LSTMCell",n.m7h.registerClass(lt);class ht extends it{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new lt(t),super(t)}call(t,e){return(0,n.lub)((()=>{null!=this.cell.dropoutMask&&(n.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(n.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}ht.className="LSTM",n.m7h.registerClass(ht);class ut extends nt{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return(0,n.lub)((()=>{let i=t.slice(1);const n=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?n.push(i.splice(0,t.stateSize.length)):n.push(i.splice(0,1));n.reverse();const s=[];let r;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];i=n[a],r=0===a?[t[0]].concat(i):[r[0]].concat(i),r=o.call(r,e),s.push(r.slice(1))}i=[];for(const t of s.slice().reverse())i.push(...t);return[r[0]].concat(i)}))}build(t){let e;(0,m.XO)(t)&&(t=t[0]),this.cells.forEach(((i,n)=>{(0,L.f4)(`RNNCell_${n}`,(()=>{i.build(t),e=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e,i={}){const n=[];for(const t of e.cells)n.push((0,p.v)(t,i));return new t({cells:n})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return(0,Y.FQ)(t)}setWeights(t){const e=[];for(const i of this.cells){const n=i.weights.length,s=t.splice(n);for(let t=0;t<i.weights.length;++t)e.push([i.weights[t],s[t]])}(0,Y.zb)(e)}}function ct(t){const{ones:e,rate:i,training:s=!1,count:r=1,dropoutFunc:a}=t,o=()=>null!=a?a(e(),i):C.rv(e(),i),l=()=>C.KC(o,e,s);return!r||r<=1?n.CnY(l().clone()):Array(r).fill(void 0).map(l).map((t=>n.CnY(t.clone())))}ut.className="StackedRNNCells",n.m7h.registerClass(ut);class pt extends it{constructor(t){if(t.unroll)throw new c.nj("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new c.nj("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new l.Zg({ndim:5})]}call(t,e){return n.lub((()=>{if(null!=this.cell.dropoutMask&&(n.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(n.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new c.nu("ConvRNN2D cell does not support constants");const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return n.lub((()=>{const{stateSize:e}=this.cell,i=t.shape,s=this.computeSingleOutputShape(i),r=[s[0],...s.slice(2)],a=n.lls(r);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t,e=!1){n.lub((()=>{if(!this.stateful)throw new c.j1("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,s=this.computeSingleOutputShape(i),r=[s[0],...s.slice(2)];if(null==i[0])throw new c.nu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>n.lls(r))):this.states_=[n.lls(r)];else if(null==t)n.B90(this.states_),null!=this.keptStates&&(n.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>n.lls(r))):this.states_[0]=n.lls(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new c.nu(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):n.B90(this.states_);for(let e=0;e<this.states_.length;++e){const i=t[e],s=r;if(!n.D5U.arraysEqual(i.shape,s))throw new c.nu(`State ${e} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${i.shape}`);this.states_[e]=i}}this.states_=this.states_.map((t=>n.CnY(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:i,kernelSize:n,padding:s,strides:r,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?3:2],h=t[o?4:3],u=O(l,n[0],s,r[0],a[0]),c=O(h,n[1],s,r[1],a[1]);return[...t.slice(0,2),...o?[i,u,c]:[u,c,i]]}}pt.className="ConvRNN2D";class dt extends lt{constructor(t){const{filters:e,kernelSize:i,strides:n,padding:s,dataFormat:r,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,(0,d.iQ)(this.filters,"filters"),this.kernelSize=F(i,2,"kernelSize"),this.kernelSize.forEach((t=>(0,d.iQ)(t,"kernelSize"))),this.strides=F(n||1,2,"strides"),this.strides.forEach((t=>(0,d.iQ)(t,"strides"))),this.padding=s||"valid",(0,L.zb)(this.padding),this.dataFormat=r||"channelsLast",(0,L.cj)(this.dataFormat),this.dilationRate=F(a||1,2,"dilationRate"),this.dilationRate.forEach((t=>(0,d.iQ)(t,"dilationRate")))}build(t){var e;t=(0,m.Wf)(t);const i="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[i])throw new c.nu(`The channel dimension of the input should be defined. Found ${t[i]}`);const s=t[i],r=this.kernelSize.concat([s,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const i=this.biasInitializer,s=this.filters;t=new((e=class extends a.m7{apply(t,e){const r=i.apply([s]),a=n.iUs([s]),o=i.apply([2*s]);return C.mV([r,a,o])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return n.lub((()=>{if(3!==t.length)throw new c.nu(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const i=e.training||!1,s=t[0],r=t[1],a=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ct({ones:()=>n.JpU(s),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=(t,e,i)=>e&&e[i]?n.dC7(e[i],t):t;let h=l(s,o,0),u=l(s,o,1),p=l(s,o,2),d=l(s,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ct({ones:()=>n.JpU(r),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=l(r,g,0),f=l(r,g,1),y=l(r,g,2),b=l(r,g,3);const[C,S,v,w]=n.Vl2(this.kernel.read(),4,3),[k,R,T,z]=this.useBias?n.Vl2(this.bias.read(),4):[null,null,null,null];h=this.inputConv(h,C,k,this.padding),u=this.inputConv(u,S,R,this.padding),p=this.inputConv(p,v,T,this.padding),d=this.inputConv(d,w,z,this.padding);const[I,A,x,N]=n.Vl2(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,I),f=this.recurrentConv(f,A),y=this.recurrentConv(y,x),b=this.recurrentConv(b,N);const D=this.recurrentActivation.apply(n.IHx(h,m)),E=this.recurrentActivation.apply(n.IHx(u,f)),L=n.IHx(n.dC7(E,a),n.dC7(D,this.activation.apply(n.IHx(p,y)))),_=n.dC7(this.recurrentActivation.apply(n.IHx(d,b)),this.activation.apply(L));return[_,_,L]}))}getConfig(){const t=super.getConfig(),{units:e}=t,i=function(t,e){var i={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(i[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(t);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(t,n[s])&&(i[n[s]]=t[n[s]])}return i}(t,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),n)}inputConv(t,e,i,s){const r=n.Tek(t,e,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?C.a2(r,i,this.dataFormat):r}recurrentConv(t,e){return n.Tek(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}dt.className="ConvLSTM2DCell",n.m7h.registerClass(dt);class gt extends pt{constructor(t){const e=new dt(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}gt.className="ConvLSTM2D",n.m7h.registerClass(gt);class mt extends l.mh{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,i=[];for(let t=0;t<this.noiseShape.length;++t)i.push(null==this.noiseShape[t]?e[t]:this.noiseShape[t]);return i}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,n=this.getNoiseShape(i);return C.KC((()=>C.rv(i,this.rate,n,this.seed)),(()=>i),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}mt.className="Dropout",n.m7h.registerClass(mt);class ft extends mt{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}ft.className="SpatialDropout1D",n.m7h.registerClass(ft);class yt extends l.mh{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,(0,d.iQ)(this.units,"units"),this.activation=(0,b.aI)(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=(0,a.L5)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=(0,a.L5)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=(0,r.Ad)(t.kernelConstraint),this.biasConstraint=(0,r.Ad)(t.biasConstraint),this.kernelRegularizer=T(t.kernelRegularizer),this.biasRegularizer=T(t.biasRegularizer),this.activityRegularizer=T(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=(0,m.Wf)(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=(0,m.Wf)(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t),n=(0,d.WT)(this.activation.getClassName());let s;return null!=n?s=C.AK(i,this.kernel.read(),n,this.bias?this.bias.read():null):(s=C.AK(i,this.kernel.read()),null!=this.bias&&(s=C.a2(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const t={units:this.units,activation:(0,b.GD)(this.activation),useBias:this.useBias,kernelInitializer:(0,a.Cx)(this.kernelInitializer),biasInitializer:(0,a.Cx)(this.biasInitializer),kernelRegularizer:k(this.kernelRegularizer),biasRegularizer:k(this.biasRegularizer),activityRegularizer:k(this.activityRegularizer),kernelConstraint:(0,r.xF)(this.kernelConstraint),biasConstraint:(0,r.xF)(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}yt.className="Dense",n.m7h.registerClass(yt);class bt extends l.mh{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=(0,m.Wf)(t);for(const e of t.slice(1))if(null==e)throw new c.nu(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],(0,_.NS)(t,1)]}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);let i=(0,m.nQ)(t);if("channelsFirst"===this.dataFormat&&i.rank>1){const t=[0];for(let e=2;e<i.rank;++e)t.push(e);t.push(1),i=(0,n.p4s)(i,t)}return C.Uz(i)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}bt.className="Flatten",n.m7h.registerClass(bt);class Ct extends l.mh{constructor(t){super(t),this.supportsMasking=!0,this.activation=(0,b.aI)(t.activation)}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t);return this.activation.apply(i)}))}getConfig(){const t={activation:(0,b.GD)(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}Ct.className="Activation",n.m7h.registerClass(Ct);class St extends l.mh{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return(0,n.lub)((()=>(t=(0,m.nQ)(t),C.rx(t,this.n))))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}St.className="RepeatVector",n.m7h.registerClass(St);class vt extends l.mh{constructor(t){super(t),this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const i="Total size of new array must be unchanged.",n=e.slice();let s=1,r=null;for(let t=0;t<n.length;++t){const e=n[t];if(this.isUnknown(e)){if(null!==r)throw new c.nu("Can only specifiy one unknown dimension.");r=t}else s*=e}const a=(0,_.NS)(t);if(null!==r){if(0===s||a%s!=0)throw new c.nu(i);n[r]=a/s}else if(a!==s)throw new c.nu(i);return n}computeOutputShape(t){let e=!1;for(let i=0;i<t.length;++i)if(this.isUnknown(t[i])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t),s=i.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return(0,n.XLQ)(i,r)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}vt.className="Reshape",n.m7h.registerClass(vt);class wt extends l.mh{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=(0,_.w6)(1,t.dims.length+1);if(!n.D5U.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new l.Zg({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=(0,m.Wf)(t)).slice();return this.dims.forEach(((i,n)=>{e[n+1]=t[i]})),e}call(t,e){return(0,n.p4s)((0,m.nQ)(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}wt.className="Permute",n.m7h.registerClass(wt);class kt extends l.mh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const i=(0,m.nQ)(t);return(0,n.YjB)((0,n.Quu)(i,this.maskValue),-1)}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t),s=(0,n.YjB)((0,n.Quu)(i,this.maskValue),-1,!0);return(0,n.dC7)(i,(0,n.pju)(s,i.dtype))}))}}kt.className="Masking",n.m7h.registerClass(kt);class Rt extends l.mh{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(d.zZ(t.inputLength))}this.inputDim=t.inputDim,d.iQ(this.inputDim,"inputDim"),this.outputDim=t.outputDim,d.iQ(this.outputDim,"outputDim"),this.embeddingsInitializer=(0,a.L5)(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=T(t.embeddingsRegularizer),this.activityRegularizer=T(t.activityRegularizer),this.embeddingsConstraint=(0,r.Ad)(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return(0,n.lub)((()=>this.maskZero?(t=(0,m.nQ)(t),(0,n.Quu)(t,(0,n.P84)(t))):null))}computeOutputShape(t){if(t=(0,m.Wf)(t),null==this.inputLength)return[...t,this.outputDim];const e=d.zZ(this.inputLength);if(e.length!==t.length-1)throw new c.nu(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let i=0;for(let n=0;n<e.length;++n){const s=e[n],r=t[n+1];if(null!=s&&null!=r&&s!==r)throw new c.nu(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==s&&(e[i]=r),i++}}return[t[0],...e,this.outputDim]}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);let i=(0,m.nQ)(t);"int32"!==i.dtype&&(i=C.pj(i,"int32"));const s=C.Iq(this.embeddings.read(),(0,n.XLQ)(i,[i.size]));return(0,n.XLQ)(s,(0,m.Wf)(this.computeOutputShape(i.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:(0,a.Cx)(this.embeddingsInitializer),embeddingsRegularizer:k(this.embeddingsRegularizer),activityRegularizer:k(this.activityRegularizer),embeddingsConstraint:(0,r.xF)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}Rt.className="Embedding",n.m7h.registerClass(Rt);var Tt=i(86275);class zt extends l.mh{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new c.nj}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const i=t.slice(0,t.length-e.length);for(let n=0;n<e.length;++n){const s=t[t.length-e.length+n],r=e[n];if(null==s||null==r||s<0||r<0)i.push(null);else if(1===s)i.push(r);else if(1===r)i.push(s);else{if(s!==r)throw new c.nu("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));i.push(s)}}return i}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[(0,m.Wf)(t)]),t.length<2)throw new c.nu(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=d.Tw(e),e.length>1)throw new c.nu(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let i=null==t[0]?null:t[0].slice(1);for(let e=1;e<t.length;++e){const n=null==t[e]?null:t[e].slice(1);i=this.computeElementwiseOpOutputShape(i,n)}const n=t.map((t=>t.length));-1===t.indexOf(null)&&1===d.Tw(n).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return(0,n.lub)((()=>{if(this.reshapeRequired){const e=[],i=t.map((t=>t.rank));if(-1===i.indexOf(null)){const n=_.Fp(i);for(let i of t){const t=i.rank;for(let e=0;e<n-t;++e)i=C.dt(i,1);e.push(i)}return this.mergeFunction(e)}{let i=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=n.XLQ(s,[r].concat(_.NS(t.slice(1))));o=n.p4s(o,[1,0]),o=n.XLQ(o,a),e.push(o),i=!0}else if(t>1){const r=_.w6(1,t).concat([0]);e.push(n.p4s(s,r)),i=!0}else e.push(s)}let s=this.mergeFunction(e);const r=s.rank;if(i)if(null==r){const t=s.shape,e=t[t.length-1],i=[e].concat(t.slice(0,t.length-1));s=n.XLQ(n.p4s(n.XLQ(s,[-1,e]),[1,0]),i)}else if(r>1){const t=[r-1].concat(_.w6(0,r-1));s=n.p4s(s,t)}return s}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const n=null==t[i]?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let i=[];for(const e of t)null!=e&&null!==e[0]&&i.push(e[0]);return i=d.Tw(i),e=1===i.length?i.concat(e):[null].concat(e),e}computeMask(t,e){return n.lub((()=>{if(null==e)return null;if(!Array.isArray(e))throw new c.nu("`mask` should be an Array");if(!Array.isArray(t))throw new c.nu("`inputs` should be an Array");if(e.length!==t.length)throw new c.nu(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;let i=(e=e.map((t=>null==t?t:n.dt4(t,0))))[0];for(let t=1;t<e.length-1;++t)i=n.HvI(i,e[t]);return i}))}}class It extends zt{constructor(t){super(t)}mergeFunction(t){return(0,n.lub)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.IHx(e,t[i]);return e}))}}It.className="Add",n.m7h.registerClass(It);class At extends zt{constructor(t){super(t)}mergeFunction(t){return(0,n.lub)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.dC7(e,t[i]);return e}))}}At.className="Multiply",n.m7h.registerClass(At);class xt extends zt{constructor(t){super(t)}mergeFunction(t){return(0,n.lub)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.IHx(e,t[i]);return n.dC7(1/t.length,e)}))}}xt.className="Average",n.m7h.registerClass(xt);class Nt extends zt{constructor(t){super(t)}mergeFunction(t){return(0,n.lub)((()=>{let e=t[0];for(let i=1;i<t.length;++i)e=n.gWQ(e,t[i]);return e}))}}Nt.className="Maximum",n.m7h.registerClass(Nt);class Dt extends zt{constructor(t){super(t)}mergeFunction(t){return(0,n.lub)((()=>{let e=t[0];for(let i=1;i<t.length;++i)e=n.LTh(e,t[i]);return e}))}}Dt.className="Minimum",n.m7h.registerClass(Dt);class Et extends zt{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new c.nu("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const i of t)if(null!=i){e=!1;break}if(e)return;const i=[];for(let e=0;e<t.length;++e){const s=t[e].slice();s.splice(this.axis,1);let r=!1;for(const t of i)if(n.D5U.arraysEqual(t,s)){r=!0;break}r||i.push(s)}if(i.length>1)throw new c.nu("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return(0,n.lub)((()=>C.mV(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new c.nu("A `Concatenate` layer should be called on a list of inputs.");const e=t,i=e[0].slice(),n=this.axis<0?i.length+this.axis:this.axis;for(const t of e.slice(1)){if(null==i[n]||null==t[n]){i[n]=null;break}i[n]+=t[n]}return i}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new c.nu("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new c.nu("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new c.nu(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return n.lub((()=>{let i=!0;if(e.forEach((t=>{null==t||(i=!1)})),i)return null;const s=[];for(let i=0;i<t.length;++i)null==e[i]?s.push(n.pju(n.JpU(t[i]),"bool")):e[i].rank<t[i].rank?s.push(n.dt4(e[i],-1)):s.push(e[i]);const r=n.zoF(s,this.axis);return n.$6P(r,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Lt(t,e){for(;t<0;)t+=e;return t}Et.className="Concatenate",n.m7h.registerClass(Et);class _t extends zt{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){n.D5U.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],i=t[1];if(e.length>3||i.length>3)throw new c.nj("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,i);if(e[s[0]]!==i[s[1]])throw new c.nu(`Dimension incompatibility: ${e[s[0]]} !== ${i[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new c.nu(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,i=t[0],s=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,i)=>Lt(e,t[i].shape.length))):[Lt(this.axes,i.shape.length),Lt(this.axes,s.shape.length)],this.normalize&&(i=(0,Tt.Eq)(i,e[0]),s=(0,Tt.Eq)(s,e[1])),function(t,e,i){if(t.shape.length>3||e.shape.length>3)throw new c.nj("batchDot is not implemented for tensors of 4D or higher rank yet");if(n.D5U.assert(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`)),n.D5U.assert(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`)),"number"==typeof i&&(i=[i,i]),"complex64"===t.dtype||"complex64"===e.dtype)throw new c.nj("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;null==i&&(i=[s-1,r-2]);const a=i;return n.lub((()=>{let i,o;if(s>r){i=s-r;const t=[];for(let e=0;e<i;++e)t.push(1);e=n.XLQ(e,e.shape.concat(t))}else if(r>s){i=r-s;const e=[];for(let t=0;t<i;++t)e.push(1);t=n.XLQ(t,t.shape.concat(e))}else i=0;if(2===t.shape.length&&2===e.shape.length)o=a[0]===a[1]?n.Smz(n.dC7(t,e),a[0]):n.Smz(n.dC7(n.p4s(t,[1,0]),e),a[1]);else{const i=a[0]!==t.shape.length-1,s=a[1]===e.shape.length-1;o=n.OI3(t,e,i,s)}if(i>0){let t;t=s>r?s+r-3:s-1;const e=[];for(let n=t;n<t+i;++n)e.push(n);o=n.L9e(o,e)}return 1===o.shape.length&&(o=n.dt4(o,1)),o}))}(i,s,e)}interpretAxes(t,e){let i;return i=Array.isArray(this.axes)?this.axes:[Lt(this.axes,t.length),Lt(this.axes,e.length)],i}computeOutputShape(t){n.D5U.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),i=t[1].slice();if(e.length>3||i.length>3)throw new c.nj("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,i);e.splice(s[0],1),i.splice(s[1],1),i.splice(0,1);const r=e.concat(i);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}_t.className="Dot",n.m7h.registerClass(_t);class Ft extends l.mh{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t);return C.KC((()=>(0,n.IHx)(C.nG(i.shape,0,this.stddev),i)),(()=>i),e.training||!1)}))}}Ft.className="GaussianNoise",n.m7h.registerClass(Ft);class Ot extends l.mh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e);const i=(0,m.nQ)(t);if(this.rate>0&&this.rate<1){const t=()=>{const t=Math.sqrt(this.rate/(1-this.rate));return(0,n.dC7)(i,C.nG(i.shape,1,t))};return C.KC(t,(()=>i),e.training||!1)}return i}))}}Ot.className="GaussianDropout",n.m7h.registerClass(Ot);class Mt extends l.mh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||(0,m.nQ)(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return(0,n.lub)((()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(t),s=()=>{const e=(0,m.nQ)(t),s=-1.7580993408473766;let r=(0,n.brS)((0,n.LGj)(i),this.rate);r=C.pj(r,"float32");const a=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-a*s*this.rate,l=(0,n.IHx)((0,n.dC7)(e,r),(0,n.dC7)((0,n.IHx)(r,-1),s));return(0,n.IHx)((0,n.dC7)(l,a),o)};return C.KC(s,(()=>(0,m.nQ)(t)),e.training||!1)}return t}))}}function Pt(t,e,i,s,r,a=.001){let o;if(2===t.rank)o=n.Dxk(t,e,i,s,r,a);else if(3===t.rank)o=n.JY5(t,e,i,s,r,a);else{if(4!==t.rank)throw new c.nj(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=n.p3b(t,e,i,s,r,a)}return o}Mt.className="AlphaDropout",n.m7h.registerClass(Mt);class jt extends l.mh{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=(0,a.L5)(t.betaInitializer||"zeros"),this.gammaInitializer=(0,a.L5)(t.gammaInitializer||"ones"),this.movingMeanInitializer=(0,a.L5)(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=(0,a.L5)(t.movingVarianceInitializer||"ones"),this.betaConstraint=(0,r.Ad)(t.betaConstraint),this.gammaConstraint=(0,r.Ad)(t.gammaConstraint),this.betaRegularizer=T(t.betaRegularizer),this.gammaRegularizer=T(t.gammaRegularizer)}build(t){t=(0,m.Wf)(t);const e=this.axis>=0?this.axis:this.axis+t.length,i=t[e];if(null==i)throw new c.nu(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new l.Zg({ndim:t.length,axes:{[e]:i}})];const n=[i];this.scale&&(this.gamma=this.addWeight("gamma",n,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",n,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",n,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",n,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return(0,n.lub)((()=>{const i=null!=e.training&&e.training,s=(0,m.nQ)(t),r=s.shape,a=r.length,o=_.w6(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const h=d.JE(1,a);h[l]=r[l];const u=o.slice();u.sort();const c=!n.D5U.arraysEqual(u,_.w6(0,a).slice(0,a-1));if(!i)return(()=>{if(c){const t=(0,n.XLQ)(this.movingMean.read(),h),e=(0,n.XLQ)(this.movingVariance.read(),h),i=this.center?(0,n.XLQ)(this.beta.read(),h):null,r=this.scale?(0,n.XLQ)(this.gamma.read(),h):null;return Pt(s,t,e,i,r,this.epsilon)}return Pt(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,g,f]=function(t,e,i,s,r=.001){return n.D5U.arraysEqual(s.slice().sort(),_.w6(0,t.rank-1))?function(t,e,i,s,r=.001){return(0,n.lub)((()=>{const a=n.Gi7(t,s),o=a.mean,l=a.variance;return[Pt(t,o,l,i,e,r),o,l]}))}(t,e,i,s,r):function(t,e,i,s,r=.001){return(0,n.lub)((()=>{const a=n.Gi7(t,s),o=a.mean,l=a.variance,h=[];for(const e of _.w6(0,t.rank))-1!==s.indexOf(e)?h.push(1):h.push(t.shape[e]);const u=(0,n.XLQ)(o,h),c=(0,n.XLQ)(l,h),p=null==e?null:(0,n.XLQ)(e,h),d=null==i?null:(0,n.XLQ)(i,h);return[Pt(t,u,c,d,p,r),o,l]}))}(t,e,i,s,r)}(s,this.gamma.read(),this.beta.read(),o,this.epsilon),y=(t,e,i)=>{n.lub((()=>{const s=1-i,r=t.read(),a=n.dC7(n.luU(r,e),s);t.write(n.luU(r,a))}))};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,f,this.momentum)})(),p}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,a.Cx)(this.betaInitializer),gammaInitializer:(0,a.Cx)(this.gammaInitializer),movingMeanInitializer:(0,a.Cx)(this.movingMeanInitializer),movingVarianceInitializer:(0,a.Cx)(this.movingVarianceInitializer),betaRegularizer:k(this.betaRegularizer),gammaRegularizer:k(this.gammaRegularizer),betaConstraint:(0,r.xF)(this.betaConstraint),gammaConstraint:(0,r.xF)(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}jt.className="BatchNormalization",n.m7h.registerClass(jt);class Ut extends l.mh{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=(0,a.L5)(t.betaInitializer||"zeros"),this.gammaInitializer=(0,a.L5)(t.gammaInitializer||"ones"),this.betaRegularizer=T(t.betaRegularizer),this.gammaRegularizer=T(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=(0,m.Wf)(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let t=0;t<this.axis.length;++t)this.axis[t]<0&&(this.axis[t]+=e);for(const t of this.axis)if(t<0||t>=e)throw new Error(`Invalid axis: ${t}`);if(this.axis.length!==d.Tw(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(t,e){const i=(0,m.nQ)(t),s=i.shape,r=s.length;return(0,n.lub)((()=>{let{mean:t,variance:e}=(0,n.Gi7)(i,this.axis,!0);const a=d.JE(1,r);for(const t of this.axis)a[t]=s[t];const o=t=>null!=t&&t.shape.length!==r?n.XLQ(t,a):t;let l=this.scale?o(this.gamma.read()):null,h=this.center?o(this.beta.read()):null;const u=[],c=[];for(let t=0;t<r;++t)-1!==this.axis.indexOf(t)?(u.push(s[t]),c.push(1)):(u.push(1),c.push(s[t]));return t=n.Gg6(t,u),e=n.Gg6(e,u),null!=l&&(l=n.Gg6(l,c)),null!=h&&(h=n.Gg6(h,c)),Pt(i,t,e,h,l,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,a.Cx)(this.betaInitializer),gammaInitializer:(0,a.Cx)(this.gammaInitializer),betaRegularizer:k(this.betaRegularizer),gammaRegularizer:k(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Ut.className="LayerNormalization",n.m7h.registerClass(Ut);class Wt extends l.mh{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?(0,E.rf)():t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new c.nu(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,i;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new c.nu(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new c.nu(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);i=t.padding[1]}this.padding=[e,i]}this.inputSpec=[new l.Zg({ndim:4})]}computeOutputShape(t){let e,i;return t=(0,m.Wf)(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,i]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,i,t[3]])}call(t,e){return(0,n.lub)((()=>{return e=(0,m.nQ)(t),i=this.padding,s=this.dataFormat,(0,n.lub)((()=>{if(4!==e.rank)throw new c.nu(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==i&&(i=[[1,1],[1,1]]),2!==i.length||2!==i[0].length||2!==i[1].length)throw new c.nu("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s=(0,E.rf)()),"channelsLast"!==s&&"channelsFirst"!==s)throw new c.nu(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===s?[[0,0],[0,0],i[0],i[1]]:[[0,0],i[0],i[1],[0,0]],n.vku(e,t)}));var e,i,s}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function $t(t,e,i,s,r,a){return(0,n.lub)((()=>{let o;(0,L.cj)(r),(0,L.Lp)(a),(0,L.zb)(s),null==i&&(i=[1,1]),null==s&&(s="valid"),null==r&&(r=(0,E.rf)()),null==a&&(a="max"),t=P(t,r);const l="same"===s?"same":"valid";return o="max"===a?n._sB(t,e,i,l):n.wS1(t,e,i,l),"channelsFirst"===r&&(o=n.p4s(o,[0,3,1,2])),o}))}function Bt(t,e,i,s,r,a){return(0,n.lub)((()=>{let o;(0,L.cj)(r),(0,L.Lp)(a),(0,L.zb)(s),null==i&&(i=[1,1,1]),null==s&&(s="valid"),null==r&&(r=(0,E.rf)()),null==a&&(a="max"),t=j(t,r);const l="same"===s?"same":"valid";return o="max"===a?n.YQQ(t,e,i,l):n.uR5(t,e,i,l),"channelsFirst"===r&&(o=n.p4s(o,[0,4,1,2,3])),o}))}Wt.className="ZeroPadding2D",n.m7h.registerClass(Wt);class Ht extends l.mh{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new c.nu(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if((0,d.iQ)(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new c.nu(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}(0,d.iQ)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,(0,L.zb)(this.padding),this.inputSpec=[new l.Zg({ndim:3})]}computeOutputShape(t){const e=O((t=(0,m.Wf)(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return(0,n.lub)((()=>{this.invokeCallHook(t,e),t=C.dt((0,m.nQ)(t),2);const i=this.poolingFunction((0,m.nQ)(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return n.L9e(i,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Qt extends Ht{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),$t(t,e,i,n,s,"max")}}Qt.className="MaxPooling1D",n.m7h.registerClass(Qt);class Jt extends Ht{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),$t(t,e,i,n,s,"avg")}}Jt.className="AveragePooling1D",n.m7h.registerClass(Jt);class Vt extends l.mh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new c.nu(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];(0,d.iQ)(this.poolSize,"poolSize"),(0,d.iQ)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,(0,L.cj)(this.dataFormat),(0,L.zb)(this.padding),this.inputSpec=[new l.Zg({ndim:4})]}computeOutputShape(t){t=(0,m.Wf)(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2];return e=O(e,this.poolSize[0],this.padding,this.strides[0]),i=O(i,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i]:[t[0],e,i,t[3]]}call(t,e){return(0,n.lub)((()=>(this.invokeCallHook(t,e),this.poolingFunction((0,m.nQ)(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Gt extends Vt{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),$t(t,e,i,n,s,"max")}}Gt.className="MaxPooling2D",n.m7h.registerClass(Gt);class Zt extends Vt{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),$t(t,e,i,n,s,"avg")}}Zt.className="AveragePooling2D",n.m7h.registerClass(Zt);class qt extends l.mh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new c.nu(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];(0,d.iQ)(this.poolSize,"poolSize"),(0,d.iQ)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,(0,L.cj)(this.dataFormat),(0,L.zb)(this.padding),this.inputSpec=[new l.Zg({ndim:5})]}computeOutputShape(t){t=(0,m.Wf)(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[4]:t[3];return e=O(e,this.poolSize[0],this.padding,this.strides[0]),i=O(i,this.poolSize[1],this.padding,this.strides[1]),n=O(n,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i,n]:[t[0],e,i,n,t[4]]}call(t,e){return(0,n.lub)((()=>(this.invokeCallHook(t,e),this.poolingFunction((0,m.nQ)(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Kt extends qt{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),Bt(t,e,i,n,s,"max")}}Kt.className="MaxPooling3D",n.m7h.registerClass(Kt);class Xt extends qt{constructor(t){super(t)}poolingFunction(t,e,i,n,s){return(0,L.cj)(s),(0,L.zb)(n),Bt(t,e,i,n,s,"avg")}}Xt.className="AveragePooling3D",n.m7h.registerClass(Xt);class Yt extends l.mh{constructor(t){super(t),this.inputSpec=[new l.Zg({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new c.nj}}class te extends Yt{constructor(t){super(t||{})}call(t,e){return(0,n.lub)((()=>{const e=(0,m.nQ)(t);return n.J69(e,1)}))}}te.className="GlobalAveragePooling1D",n.m7h.registerClass(te);class ee extends Yt{constructor(t){super(t||{})}call(t,e){return(0,n.lub)((()=>{const e=(0,m.nQ)(t);return n.Fp7(e,1)}))}}ee.className="GlobalMaxPooling1D",n.m7h.registerClass(ee);class ie extends l.mh{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,(0,L.cj)(this.dataFormat),this.inputSpec=[new l.Zg({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new c.nj}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class ne extends ie{call(t,e){return(0,n.lub)((()=>{const e=(0,m.nQ)(t);return"channelsLast"===this.dataFormat?n.J69(e,[1,2]):n.J69(e,[2,3])}))}}ne.className="GlobalAveragePooling2D",n.m7h.registerClass(ne);class se extends ie{call(t,e){return(0,n.lub)((()=>{const e=(0,m.nQ)(t);return"channelsLast"===this.dataFormat?n.Fp7(e,[1,2]):n.Fp7(e,[2,3])}))}}se.className="GlobalMaxPooling2D",n.m7h.registerClass(se);var re=i(44685);class ae extends l.mh{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,i={}){const n=e.layer,s=(0,p.v)(n,i);delete e.layer;const r={layer:s};return Object.assign(r,e),new t(r)}}class oe extends ae{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=(0,m.Wf)(t)).length<3)throw new c.nu(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=(0,m.Wf)(t))[0]].concat(t.slice(2)),i=this.layer.computeOutputShape(e),n=t[1];return[i[0],n].concat(i.slice(1))}call(t,e){return(0,n.lub)((()=>et(((t,i)=>[(0,m.nQ)(this.layer.call(t,e)),[]]),t=(0,m.nQ)(t),[],!1,null,null,!1,!0)[1]))}}oe.className="TimeDistributed",n.m7h.registerClass(oe);class le extends ae{constructor(t){super(t);const e=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=e,this.forwardLayer=(0,p.v)(i),e.goBackwards=!0!==e.goBackwards;const n={};var s;if(n.className=t.layer.getClassName(),n.config=e,this.backwardLayer=(0,p.v)(n),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,s=this.mergeMode,d.xn(re.eY,"BidirectionalMergeMode",s),t.weights)throw new c.nj("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,i=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,i)),this.backwardLayer.setWeights(t.slice(i))}computeOutputShape(t){let e,i,n,s=this.forwardLayer.computeOutputShape(t);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(n=s.slice(1),e=s[0]):e=s[0],"concat"===this.mergeMode?(e[e.length-1]*=2,i=[e]):i=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?i.concat(n).concat(n.slice()):[e].concat(n).concat(n.slice()):d.Bq(i)}apply(t,e){let i=null==e?null:e.initialState,n=null==e?null:e.constants;null==e&&(e={});const s=tt(t,i,n,this.numConstants);if(t=s.inputs,i=s.initialState,n=s.constants,Array.isArray(t)&&(i=t.slice(1),t=t[0]),(null==i||0===i.length)&&null==n)return super.apply(t,e);const r=[],a=[];if(null!=i){const t=i.length;if(t%2>0)throw new c.nu("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=i,r.push(...i);const n=i.map((t=>new l.Zg({shape:t.shape})));this.forwardLayer.stateSpec=n.slice(0,t/2),this.backwardLayer.stateSpec=n.slice(t/2),a.push(...n)}if(null!=n)throw new c.nj("Support for constants in Bidirectional layers is not implemented yet.");const o=r[0]instanceof l.Iy;for(const t of r)if(t instanceof l.Iy!==o)throw new c.nu("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const i=[t].concat(r),n=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=n;const o=super.apply(i,e);return this.inputSpec=s,o}return super.apply(t,e)}call(t,e){return(0,n.lub)((()=>{const i=e.initialState;let s,r,a,o;if(null==i)s=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const n=i.slice(0,i.length/2),a=i.slice(i.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:n})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=n.GYS(r,1)),"concat"===this.mergeMode?o=C.mV([s,r]):"sum"===this.mergeMode?o=n.IHx(s,r):"ave"===this.mergeMode?o=n.dC7(.5,n.IHx(s,r)):"mul"===this.mergeMode?o=n.dC7(s,r):null==this.mergeMode&&(o=[s,r]),this.returnState?null==this.mergeMode?o.concat(a):[o].concat(a):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){(0,L.f4)(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),(0,L.f4)(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let i;if(Array.isArray(e)&&(e=e[0]),i=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(i)?i.concat(t).concat(t):[i].concat(t).concat(t)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const i=(0,p.v)(e.layer);if(delete e.layer,null!=e.numConstants)throw new c.nj("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const n=e;return n.layer=i,new t(n)}}le.className="Bidirectional",n.m7h.registerClass(le);class he extends l.mh{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return(0,n.lub)((()=>("float32"!==(t=(0,m.nQ)(t)).dtype&&(t=C.pj(t,"float32")),(0,n.IHx)((0,n.dC7)(t,this.scale),this.offset))))}}he.className="Rescaling",n.m7h.registerClass(he);const{resizeBilinear:ue,cropAndResize:ce}=n.BHj;class pe extends l.mh{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,i,s,r,a,o,l){return(0,n.lub)((()=>{let h,u=!1;const c=[e/a,i/o,(s+e)/a,(r+i)/o],p=[];3===t.rank?(u=!0,h=(0,n.knu)([t])):h=t;for(let t=0;t<h.shape[0];t++)p.push(c);const d=(0,n.XeE)(p,[p.length,4]),g=(0,n.w6H)(0,p.length,1,"int32"),f=ce(h,d,g,[s,r],"nearest");return u?C.pj((0,m.nQ)((0,n.HHK)(f)),l):C.pj(f,l)}))}upsize(t,e,i,s){return(0,n.lub)((()=>{const n=ue(t,[e,i]);return C.pj(n,s)}))}call(t,e){return(0,n.lub)((()=>{const e=(0,m.nQ)(t),i=e.dtype,n=e.shape,s=n[n.length-3],r=n[n.length-2];let a=0;s!==this.height&&(a=Math.floor((s-this.height)/2));let o=0;return r!==this.width&&(o=Math.floor((r-this.width)/2),0===o&&(o=1)),a>=0&&o>=0?this.centerCrop(e,a,o,this.height,this.width,s,r,i):this.upsize(t,this.height,this.width,i)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=(0,m.Wf)(t)).length-3,i=t.length-2;return t[e]=this.height,t[i]=this.width,t}}pe.className="CenterCrop",n.m7h.registerClass(pe);class de extends l.mh{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=(0,m.Wf)(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return(0,n.lub)((()=>{let i;if("int32"!==(t=(0,m.nQ)(t)).dtype&&(t=C.pj(t,"int32")),void 0!==e.countWeights){if("count"!==this.outputMode)throw new c.nu(`countWeights is not used when outputMode !== count.\n              Received countWeights=${e.countWeights}`);i=(0,m.nQ)(e.countWeights)}const s=(0,n.Fp7)(t),r=(0,n.VV$)(t),a=(0,n.pjt)(this.numTokens,s).bufferSync().get(0),o=(0,n.brS)(r,0).bufferSync().get(0);if(!a||!o)throw new c.nu(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(t,e,i,s){let r=(0,m.nQ)(t);if("int32"!==r.dtype&&(r=C.pj(r,"int32")),"int"===e)return r;const a=r.shape;if(0===r.rank&&(r=(0,n.dt4)(r,-1)),"oneHot"===e&&1!==r.shape[r.shape.length-1]&&(r=(0,n.dt4)(r,-1)),r.rank>2)throw new c.nu(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),l=r;let h;if(h=void 0!==s&&"count"===e?(0,n.ppE)(l,s,i,o):(0,n.ppE)(l,[],i,o),"tfIdf"!==e)return h;if(s)return(0,n.dC7)(h,s);throw new c.nu("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,i)}))}}de.className="CategoryEncoding",n.m7h.registerClass(de);const ge=new Set(["bilinear","nearest"]);class me extends l.mh{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!ge.has(t.interpolation))throw new c.nu(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=(0,m.Wf)(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return(0,n.lub)((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return n.BHj.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return n.BHj.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ge]} are supported`)}))}}me.className="Resizing",n.m7h.registerClass(me),i(38678),i(66084)},85654:(t,e,i)=>{i.d(e,{m7:()=>c,M6:()=>d,L5:()=>N,Cx:()=>x});var n=i(88478),s=i(39840),r=i(48090),a=i(40588);const o=["fanIn","fanOut","fanAvg"],l=["normal","uniform","truncatedNormal"];var h=i(2931),u=i(96040);class c extends n.m7h.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class p extends c{apply(t,e){return(0,n.lls)(t,e)}}p.className="Zeros",n.m7h.registerClass(p);class d extends c{apply(t,e){return(0,n.iUs)(t,e)}}d.className="Ones",n.m7h.registerClass(d);class g extends c{constructor(t){if(super(),"object"!=typeof t)throw new a.nu(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new a.nu(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return(0,n.lub)((()=>(0,n.dC7)((0,n.iD$)(this.value),(0,n.iUs)(t,e))))}getConfig(){return{value:this.value}}}g.className="Constant",n.m7h.registerClass(g);class m extends c{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return(0,n.LGj)(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}m.className="RandomUniform",n.m7h.registerClass(m);class f extends c{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new a.nj(`randomNormal does not support dType ${e}.`);return s.nG(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}f.className="RandomNormal",n.m7h.registerClass(f);class y extends c{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new a.nj(`truncatedNormal does not support dType ${e}.`);return(0,n.Xu6)(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}y.className="TruncatedNormal",n.m7h.registerClass(y);class b extends c{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return(0,n.lub)((()=>{if(2!==t.length||t[0]!==t[1])throw new a.nu("Identity matrix initializer can only be used for 2D square matrices.");return(0,n.dC7)(this.gain,(0,n.iyy)(t[0]))}))}getConfig(){return{gain:this.gain}}}b.className="Identity",n.m7h.registerClass(b);class C extends c{constructor(t){if(super(),t.scale<0)throw new a.nu(`scale must be a positive float. Got: ${t.scale}`);var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,(0,h.xn)(o,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){(0,h.xn)(l,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const i=function(t,e="channelsLast"){let i,n;if((0,r.cj)(e),2===t.length)i=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=(0,u.NS)(t,2);i=t[1]*e,n=t[0]*e}else if("channelsLast"===e){const e=(0,u.NS)(t,0,t.length-2);i=t[t.length-2]*e,n=t[t.length-1]*e}}else{const e=(0,u.NS)(t);i=Math.sqrt(e),n=Math.sqrt(e)}return[i,n]}(t),s=i[0],o=i[1];let l=this.scale;if("fanIn"===this.mode?l/=Math.max(1,s):"fanOut"===this.mode?l/=Math.max(1,o):l/=Math.max(1,(s+o)/2),"normal"===this.distribution){const i=Math.sqrt(l);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new a.nj(`${this.getClassName()} does not support dType ${e}.`);return(0,n.Xu6)(t,0,i,e,this.seed)}{const i=Math.sqrt(3*l);return(0,n.LGj)(t,-i,i,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}C.className="VarianceScaling",n.m7h.registerClass(C);class S extends C{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}S.className="GlorotUniform",n.m7h.registerClass(S);class v extends C{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}v.className="GlorotNormal",n.m7h.registerClass(v);class w extends C{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}w.className="HeNormal",n.m7h.registerClass(w);class k extends C{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}k.className="HeUniform",n.m7h.registerClass(k);class R extends C{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}R.className="LeCunNormal",n.m7h.registerClass(R);class T extends C{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}T.className="LeCunUniform",n.m7h.registerClass(T);class z extends c{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new a.nj("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return(0,n.lub)((()=>{if(t.length<2)throw new a.nj("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=t[0]>t[1]?[t[1],t[0]]:t,i=s.nG(e,0,1,"float32");let r=n.$r2.gramSchmidt(i);return t[0]>t[1]&&(r=(0,n.p4s)(r)),(0,n.dC7)(this.gain,r)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}z.className="Orthogonal",n.m7h.registerClass(z);const I={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function A(t,e={}){return(0,h.tU)(t,n.m7h.SerializationMap.getMap().classNameMap,e,"initializer")}function x(t){return(0,h.Kj)(t)}function N(t){if("string"==typeof t){const e=t in I?I[t]:t;if("GlorotNormal"===e)return new v;if("GlorotUniform"===e)return new S;if("HeNormal"===e)return new w;if("HeUniform"===e)return new k;if("LeCunNormal"===e)return new R;if("LeCunUniform"===e)return new T;{const t={};return t.className=e,t.config={},A(t)}}return t instanceof c?t:A(t)}},44685:(t,e,i)=>{i.d(e,{MK:()=>a,Mz:()=>s,PS:()=>n,eY:()=>o,zx:()=>r});const n=["channelsFirst","channelsLast"],s=["nearest","bilinear"],r=["valid","same","causal"],a=["max","avg"],o=["sum","mul","concat","ave"]},49897:(t,e,i)=>{i.d(e,{v:()=>r});var n=i(88478),s=i(2931);function r(t,e={},i=!1){return(0,s.tU)(t,n.m7h.SerializationMap.getMap().classNameMap,e,"layer",i)}},73146:(t,e,i)=>{i.d(e,{Z:()=>s,i:()=>r});var n=i(88478);async function s(t){if(null==t)return;const e=[],i=[],s=[];for(const n in t){const r=t[n];if("number"!=typeof r){const t=r;e.push(t.data()),i.push(n),s.push(t)}}if(e.length>0){const r=await Promise.all(e);for(let e=0;e<r.length;++e)t[i[e]]=r[e][0];(0,n.B90)(s)}}function r(t){if(null!=t)for(const e in t){const i=t[e];"number"!=typeof i&&i.dispose()}}},86275:(t,e,i)=>{i.d(e,{Eq:()=>o,FD:()=>l,KM:()=>p,Ls:()=>g,U2:()=>f,dr:()=>m,fO:()=>d,ke:()=>h,t3:()=>u,uq:()=>c});var n=i(88478),s=i(12012),r=i(39840),a=i(40588);function o(t,e){return(0,n.lub)((()=>{"float32"!==t.dtype&&(t=n.pju(t,"float32"));const i=n.Smz(r.h6(t),e,!0),a=n.hlL(i.shape,(0,s.Ho)()),o=n._b3(n.gWQ(i,a));return n.hiC(t,o)}))}function l(t,e){return(0,n.lub)((()=>n.J69(r.h6(n.luU(e,t)),-1)))}function h(t,e){return(0,n.lub)((()=>n.J69(n.WnP(n.luU(e,t)),-1)))}function u(t,e){return(0,n.lub)((()=>{const i=n.luU(t,e),r=n.iUl(n.WnP(t),(0,s.Ho)(),Number.MAX_VALUE),a=n.WnP(n.hiC(i,r));return n.dC7(100,n.J69(a,-1))}))}function c(t,e,i=!1){return(0,n.lub)((()=>{if(i)e=n.XAC(e);else{const t=n.Smz(e,e.shape.length-1,!0);e=n.hiC(e,t)}return e=n.iUl(e,(0,s.Ho)(),1-(0,s.Ho)()),n.W76(n.Smz(n.dC7(n.pju(t,"float32"),n.cM7(e)),e.shape.length-1))}))}function p(t,e,i=!1){return(0,n.lub)((()=>{const a=n.pju(n.GWj(r.xH(t)),"int32"),o=(e=n.iUl(e,(0,s.Ho)(),1-(0,s.Ho)())).shape;return c(n.XLQ(n.lfX(a,o[o.length-1]),o),e,i)}))}function d(t,e){return(0,n.lub)((()=>{let i;return i=n.iUl(e,(0,s.Ho)(),1-(0,s.Ho)()),i=n.cM7(n.hiC(i,n.luU(1,i))),n.J69(function(t,e){if(!n.D5U.arraysEqual(t.shape,e.shape))throw new a.nu(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return(0,n.lub)((()=>{const i=n.UYe(e),s=n.W76(n.WnP(e));return n.IHx(n.luU(i,n.dC7(e,t)),n.Krr(n.Qqt(s)))}))}(t,i),-1)}))}function g(t,e){return(0,n.lub)((()=>{const i=o(t,-1),s=o(e,-1),r=n.dC7(i,s);return n.W76(n.Smz(r,-1))}))}const m={meanSquaredError:l,meanAbsoluteError:h,meanAbsolutePercentageError:u,meanSquaredLogarithmicError:function(t,e){return(0,n.lub)((()=>{const i=n.iUl(e,(0,s.Ho)(),Number.MAX_VALUE),a=n.cM7(n.IHx(1,i)),o=n.iUl(t,(0,s.Ho)(),Number.MAX_VALUE),l=n.cM7(n.IHx(1,o));return n.J69(r.h6(n.luU(a,l)),-1)}))},squaredHinge:function(t,e){return(0,n.lub)((()=>{const i=n.gWQ(0,n.luU(1,n.dC7(t,e)));return n.J69(r.h6(i),-1)}))},hinge:function(t,e){return(0,n.lub)((()=>{const i=n.gWQ(0,n.luU(1,n.dC7(t,e)));return n.J69(i,-1)}))},categoricalHinge:function(t,e){return(0,n.lub)((()=>{const i=n.Smz(n.dC7(t,e),-1),s=n.Fp7(n.dC7(n.luU(1,t),e),-1);return n.gWQ(0,n.IHx(1,n.luU(s,i)))}))},logcosh:function(t,e){return(0,n.lub)((()=>{const i=Math.log(2),s=n.luU(e,t),r=n.luU(n.IHx(s,n.Wvh(n.dC7(-2,s))),i);return n.J69(r,-1)}))},categoricalCrossentropy:c,sparseCategoricalCrossentropy:p,binaryCrossentropy:d,kullbackLeiblerDivergence:function(t,e){return(0,n.lub)((()=>{const i=n.iUl(t,(0,s.Ho)(),1),r=n.iUl(e,(0,s.Ho)(),1);return n.Smz(n.dC7(t,n.cM7(n.hiC(i,r))),-1)}))},poisson:function(t,e){return(0,n.lub)((()=>{const i=n.cM7(n.IHx((0,s.Ho)(),e));return n.J69(n.luU(e,n.dC7(t,i)),-1)}))},cosineProximity:g};function f(t){if("string"==typeof t){if(t in m)return m[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new a.nu(e)}return t}},38678:(t,e,i)=>{i.d(e,{G5:()=>h,KM:()=>S,TY:()=>c,U2:()=>w,_F:()=>l,aI:()=>k,fO:()=>u,uq:()=>b});var n=i(88478),s=i(39840),r=i(40588),a=i(86275),o=i(2931);function l(t,e){return(0,n.lub)((()=>{const i=n.dC7(.5,n.JpU(e)),r=s.pj(n.pjt(e,i),t.dtype);return n.J69(n.DgJ(t,r),-1)}))}function h(t,e){return(0,n.lub)((()=>s.pj(n.DgJ(n.NqF(t,-1),n.NqF(e,-1)),"float32")))}function u(t,e){return(0,a.fO)(t,e)}function c(t,e){return t.rank===e.rank&&(t=n.L9e(t,[t.rank-1])),(e=n.NqF(e,-1)).dtype!==t.dtype&&(e=n.pju(e,t.dtype)),n.pju(n.DgJ(t,e),"float32")}const p=a.FD,d=a.FD,g=a.ke,m=a.ke,f=a.t3,y=a.t3,b=a.uq,C=a.Ls,S=a.KM,v={binaryAccuracy:l,categoricalAccuracy:h,precision:function(t,e){return(0,n.lub)((()=>{const i=function(t,e){return(0,n.lub)((()=>n.pju(n.Smz(n.HvI(n.DgJ(t,1),n.DgJ(e,1))),"float32")))}(t,e),s=function(t,e){return(0,n.lub)((()=>n.pju(n.Smz(n.HvI(n.DgJ(t,0),n.DgJ(e,1))),"float32")))}(t,e),r=n.IHx(i,s);return n.pju(n.arb(n.pjt(r,0),n.hiC(i,r),0),"float32")}))},categoricalCrossentropy:b,sparseCategoricalCrossentropy:S,mse:p,MSE:d,mae:g,MAE:m,mape:f,MAPE:y,cosine:C};function w(t){if("string"==typeof t&&t in v)return v[t];if("string"!=typeof t&&null!=t)return t;throw new r.nu(`Unknown metric ${t}`)}function k(t){if(o.hu(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const i of Object.keys(a.dr))if(a.dr[i]===t){e=i;break}if(void 0!==e)return e;for(const i of Object.keys(v))if(v[i]===t){e=i;break}return void 0!==e?e:t.name}}},92328:(t,e,i)=>{i.d(e,{j:()=>a});var n=i(88478),s=i(12012),r=i(40588);function a(t){const e={Adagrad:()=>n.p_j.adagrad(.01),Adadelta:()=>n.p_j.adadelta(1,.95,(0,s.Ho)()),Adam:()=>n.p_j.adam(.001,.9,.999,(0,s.Ho)()),Adamax:()=>n.p_j.adamax(.002,.9,.999,(0,s.Ho)(),0),RMSProp:()=>n.p_j.rmsprop(.001,.9,0,(0,s.Ho)()),SGD:()=>n.p_j.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new r.nu(`Unknown Optimizer ${t}`)}},38374:(t,e,i)=>{i.d(e,{WE:()=>n});function n(t,e,i=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!s(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(i){const i=JSON.stringify(t);i.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${i.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function s(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const i of e){if("string"!=typeof i)return!1;if(!s(t[i]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!s(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}},6247:(t,e,i)=>{i.d(e,{s:()=>n});class n{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}},2931:(t,e,i)=>{i.d(e,{Bq:()=>l,D1:()=>u,Ds:()=>k,JE:()=>r,Kj:()=>d,L7:()=>f,Mx:()=>S,QX:()=>o,Tw:()=>y,WT:()=>R,hu:()=>a,iQ:()=>v,nK:()=>b,tU:()=>m,xn:()=>C,zW:()=>c,zZ:()=>h});var n=i(88478),s=i(40588);function r(t,e){if(Array.isArray(t)){let i=[];for(let n=0;n<e;n++)i=i.concat(t);return i}{const i=new Array(e);return i.fill(t),i}}function a(t,e){if(!t)throw new s.ps(e)}function o(t,e){let i=0;for(const n of t)n===e&&i++;return i}function l(t){return 1===t.length?t[0]:t}function h(t){return Array.isArray(t)?t:[t]}function u(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function c(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let p={};function d(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function g(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((t=>g(t)));else{const e=Object.keys(t);for(const i of e){const e=t[i];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?g(e):t[i]=e.value)}}}function m(t,e={},i={},n="object",r=!1){if("string"==typeof t){const r=t;let a;if(r in i)a=i[r];else if(r in p)a=p[r];else if(a=e[r],null==a)throw new s.nu(`Unknown ${n}: ${t}. This may be due to one of the following reasons:\n1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=t;if(null==a.className||null==a.config)throw new s.nu(`${n}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const o=a.className;let l,h;if(o in i?[l,h]=i[o]:o in p?[l,h]=p.className:o in e&&([l,h]=e[o]),null==l)throw new s.nu(`Unknown ${n}: ${o}. This may be due to one of the following reasons:\n1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=h){const t={};for(const e of Object.keys(p))t[e]=p[e];for(const e of Object.keys(i))t[e]=i[e];a.config.customObjects=t;const e=Object.assign({},p);for(const t of Object.keys(i))p[t]=i[t];g(a.config);const n=h(l,a.config,i,r);return p=Object.assign({},e),n}{const t=Object.assign({},p);for(const t of Object.keys(i))p[t]=i[t];const e=new l(a.config);return p=Object.assign({},t),e}}}function f(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function y(t){if(null==t)return t;const e=[];for(const i of t)-1===e.indexOf(i)&&e.push(i);return e}function b(t){if(null==t)throw new s.nu(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function C(t,e,i){if(null!=i&&t.indexOf(i)<0)throw new s.nu(`${i} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function S(t,e,i=0,n=1/0){return a(i>=0),a(n>=i),Array.isArray(t)&&t.length>=i&&t.length<=n&&t.every((t=>typeof t===e))}function v(t,e){Array.isArray(t)?(n.D5U.assert(t.length>0,(()=>`${e} is unexpectedly an empty array.`)),t.forEach(((t,i)=>v(t,`element ${i+1} of ${e}`)))):n.D5U.assert(Number.isInteger(t)&&t>0,(()=>`Expected ${e} to be a positive integer, but got ${w(t)}.`))}function w(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>w(t))).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function k(t,e,i){let s,r=null!=i?i():n.D5U.now();return(...a)=>{const o=null!=i?i():n.D5U.now();return o-r<e||(r=o,s=t(...a)),s}}function R(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}},30618:(t,e,i)=>{i.d(e,{I:()=>s});var n=i(23013);function s(t,e,i,s=console.log){const l=function(t){let e=!0;const i=[],n=[];for(const e in t.nodesByDepth)i.push(t.nodesByDepth[e]);for(const t of i){if(t.length>1||1===t.length&&t[0].inboundLayers.length>1){e=!1;break}n.push(...t)}if(e)for(const i of t.layers){let t=!1;for(const s of i.inboundNodes)if(-1!==n.indexOf(s)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),h=["Layer (type)","Input Shape","Output shape","Param #"];let u;if(l?(e=e||90,i=i||[.32,.61,.89,1]):(e=e||115,i=i||[.24,.48,.7,.8,1]),i[i.length-1]<=1&&(i=i.map((t=>Math.floor(e*t)))),!l){h.push("Receives inputs"),u=[];for(const e in t.nodesByDepth)u.push(...t.nodesByDepth[e])}s("_".repeat(e)),r(h,i,s),s("=".repeat(e));const c=t.layers;for(let t=0;t<c.length;++t)l?a(c[t],i,s):o(c[t],i,u,s),s((t===c.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const p=function(t){let e;return e=null!=t.collectedTrainableWeights?(0,n.t)(t.collectedTrainableWeights):(0,n.t)(t.trainableWeights),e}(t),d=(0,n.t)(t.nonTrainableWeights);s(`Total params: ${p+d}`),s(`Trainable params: ${p}`),s(`Non-trainable params: ${d}`),s("_".repeat(e))}function r(t,e,i=console.log){let n="";for(let i=0;i<t.length;++i)i>0&&(n=n.slice(0,n.length-1)+" "),n+=t[i],n=n.slice(0,e[i]),n+=" ".repeat(e[i]-n.length);i(n)}function a(t,e,i){let n,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){s="multiple"}try{n=JSON.stringify(t.outputShape)}catch(t){n="multiple"}r([`${t.name} (${t.getClassName()})`,s,n,t.countParams().toString()],e,i)}function o(t,e,i,n){let s,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){a="multiple"}try{s=JSON.stringify(t.outputShape)}catch(t){s="multiple"}const o=[];for(const e of t.inboundNodes)if(!(null!=i&&i.length>0&&-1===i.indexOf(e)))for(let t=0;t<e.inboundLayers.length;++t){const i=e.inboundLayers[t].name,n=e.nodeIndices[t],s=e.tensorIndices[t];o.push(`${i}[${n}][${s}]`)}const l=t.name,h=t.getClassName(),u=0===o.length?"":o[0];r([`${l} (${h})`,a,s,t.countParams().toString(),u],e,n);for(let t=1;t<o.length;++t)r(["","","","",o[t]],e,n)}},96040:(t,e,i)=>{i.d(e,{Fp:()=>o,NS:()=>r,U:()=>s,VV:()=>a,w6:()=>l});var n=i(40588);function s(t){return t===parseInt(t.toString(),10)}function r(t,e,i){null==e&&(e=0),null==i&&(i=t.length);let n=1;for(let s=e;s<i;++s)n*=t[s];return n}function a(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let i=0;i<t.length;i++){const n=t[i];n<e&&(e=n)}return e}function o(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let i=0;i<t.length;i++){const n=t[i];n>e&&(e=n)}return e}function l(t,e){if(e<t)throw new n.nu(`end (${e}) < begin (${t}) is forbidden.`);const i=[];for(let n=t;n<e;++n)i.push(n);return i}},51977:(t,e,i)=>{i.d(e,{a:()=>r,q:()=>a});var n=i(2931);function s(t,e,i){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof i}function r(t,e){if(null===t)return null;if("string"==typeof t)return n.zW(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const i=[],n=t.length;for(let a=0;a<n;++a){const n=t[a];s(e,a,n)?i.push(n):i.push(r(n,e))}return i}{const e={};for(const i of Object.keys(t)){const s=t[i];if("name"===i&&"string"==typeof s)e[i]=s;else{const t=n.zW(i);e[t]=r(s,t)}}return e}}function a(t,e){if(null==t)return null;if("string"==typeof t)return n.D1(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const i=[],n=t.length;for(let r=0;r<n;++r){const n=t[r];s(e,r,n)?i.push(n):i.push(a(n,e))}return i}{const e={};for(const i of Object.keys(t)){const s=t[i];e[n.D1(i)]="name"!==i&&"className"!==i||"string"!=typeof s?a(s,i):s}return e}}},87538:(t,e,i)=>{i.d(e,{Wf:()=>o,XO:()=>s,nQ:()=>a,x6:()=>r});var n=i(40588);function s(t){return Array.isArray(t)&&Array.isArray(t[0])}function r(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function a(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new n.nu(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function o(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new n.nu(`Expected exactly 1 Shape; got ${t.length}`)}return t}},23013:(t,e,i)=>{function n(t){let e=0;for(const i of t)0===i.shape.length?e+=1:e+=i.shape.reduce(((t,e)=>t*e));return e}i.d(e,{t:()=>n})},41653:(t,e,i)=>{i.d(e,{FQ:()=>l,fU:()=>o,zb:()=>h});var n=i(88478),s=i(79608),r=i(48090);i(40588);const a="Variable";class o{constructor(t,e="float32",i=a,o=!0,l=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=(0,s.L)(),i=null==i?a:i,this.originalName=(0,r.MU)(i),this.name=(0,r.w8)(this.originalName),this.trainable_=o,this.constraint=l,this.val=n.VD$(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function l(t){return t.map((t=>t.read()))}function h(t){t.forEach((t=>{t[0].write(t[1])}))}},77385:(t,e,i)=>{i.d(e,{i:()=>n});const n="4.2.0"},50835:(t,e,i)=>{i.d(e,{Z:()=>ht});var n={};i.r(n),i.d(n,{fixNegotiationNeeded:()=>N,shimAddTrackRemoveTrack:()=>A,shimAddTrackRemoveTrackWithNative:()=>I,shimGetDisplayMedia:()=>v,shimGetSendersWithDtmf:()=>R,shimGetStats:()=>T,shimGetUserMedia:()=>S,shimMediaStream:()=>w,shimOnTrack:()=>k,shimPeerConnection:()=>x,shimSenderReceiverGetStats:()=>z});var s={};i.r(s),i.d(s,{shimAddTransceiver:()=>j,shimCreateAnswer:()=>$,shimCreateOffer:()=>W,shimGetDisplayMedia:()=>E,shimGetParameters:()=>U,shimGetUserMedia:()=>D,shimOnTrack:()=>L,shimPeerConnection:()=>_,shimRTCDataChannel:()=>P,shimReceiverGetStats:()=>O,shimRemoveStream:()=>M,shimSenderGetStats:()=>F});var r={};i.r(r),i.d(r,{shimAudioContext:()=>K,shimCallbacksAPI:()=>Q,shimConstraints:()=>V,shimCreateOfferLegacy:()=>q,shimGetUserMedia:()=>J,shimLocalStreamsAPI:()=>B,shimRTCIceServerUrls:()=>G,shimRemoteStreamsAPI:()=>H,shimTrackEventTransceiver:()=>Z});var a={};i.r(a),i.d(a,{removeExtmapAllowMixed:()=>rt,shimAddIceCandidateNullOrEmpty:()=>at,shimConnectionState:()=>st,shimMaxMessageSize:()=>it,shimParameterlessSetLocalDescription:()=>ot,shimRTCIceCandidate:()=>tt,shimRTCIceCandidateRelayProtocol:()=>et,shimSendThrowTypeError:()=>nt});let o=!0,l=!0;function h(t,e,i){const n=t.match(e);return n&&n.length>=i&&parseInt(n[i],10)}function u(t,e,i){if(!t.RTCPeerConnection)return;const n=t.RTCPeerConnection.prototype,s=n.addEventListener;n.addEventListener=function(t,n){if(t!==e)return s.apply(this,arguments);const r=t=>{const e=i(t);e&&(n.handleEvent?n.handleEvent(e):n(e))};return this._eventMap=this._eventMap||{},this._eventMap[e]||(this._eventMap[e]=new Map),this._eventMap[e].set(n,r),s.apply(this,[t,r])};const r=n.removeEventListener;n.removeEventListener=function(t,i){if(t!==e||!this._eventMap||!this._eventMap[e])return r.apply(this,arguments);if(!this._eventMap[e].has(i))return r.apply(this,arguments);const n=this._eventMap[e].get(i);return this._eventMap[e].delete(i),0===this._eventMap[e].size&&delete this._eventMap[e],0===Object.keys(this._eventMap).length&&delete this._eventMap,r.apply(this,[t,n])},Object.defineProperty(n,"on"+e,{get(){return this["_on"+e]},set(t){this["_on"+e]&&(this.removeEventListener(e,this["_on"+e]),delete this["_on"+e]),t&&this.addEventListener(e,this["_on"+e]=t)},enumerable:!0,configurable:!0})}function c(t){return"boolean"!=typeof t?new Error("Argument type: "+typeof t+". Please use a boolean."):(o=t,t?"adapter.js logging disabled":"adapter.js logging enabled")}function p(t){return"boolean"!=typeof t?new Error("Argument type: "+typeof t+". Please use a boolean."):(l=!t,"adapter.js deprecation warnings "+(t?"disabled":"enabled"))}function d(){if("object"==typeof window){if(o)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments)}}function g(t,e){l&&console.warn(t+" is deprecated, please use "+e+" instead.")}function m(t){return"[object Object]"===Object.prototype.toString.call(t)}function f(t){return m(t)?Object.keys(t).reduce((function(e,i){const n=m(t[i]),s=n?f(t[i]):t[i],r=n&&!Object.keys(s).length;return void 0===s||r?e:Object.assign(e,{[i]:s})}),{}):t}function y(t,e,i){e&&!i.has(e.id)&&(i.set(e.id,e),Object.keys(e).forEach((n=>{n.endsWith("Id")?y(t,t.get(e[n]),i):n.endsWith("Ids")&&e[n].forEach((e=>{y(t,t.get(e),i)}))})))}function b(t,e,i){const n=i?"outbound-rtp":"inbound-rtp",s=new Map;if(null===e)return s;const r=[];return t.forEach((t=>{"track"===t.type&&t.trackIdentifier===e.id&&r.push(t)})),r.forEach((e=>{t.forEach((i=>{i.type===n&&i.trackId===e.id&&y(t,i,s)}))})),s}const C=d;function S(t,e){const i=t&&t.navigator;if(!i.mediaDevices)return;const n=function(t){if("object"!=typeof t||t.mandatory||t.optional)return t;const e={};return Object.keys(t).forEach((i=>{if("require"===i||"advanced"===i||"mediaSource"===i)return;const n="object"==typeof t[i]?t[i]:{ideal:t[i]};void 0!==n.exact&&"number"==typeof n.exact&&(n.min=n.max=n.exact);const s=function(t,e){return t?t+e.charAt(0).toUpperCase()+e.slice(1):"deviceId"===e?"sourceId":e};if(void 0!==n.ideal){e.optional=e.optional||[];let t={};"number"==typeof n.ideal?(t[s("min",i)]=n.ideal,e.optional.push(t),t={},t[s("max",i)]=n.ideal,e.optional.push(t)):(t[s("",i)]=n.ideal,e.optional.push(t))}void 0!==n.exact&&"number"!=typeof n.exact?(e.mandatory=e.mandatory||{},e.mandatory[s("",i)]=n.exact):["min","max"].forEach((t=>{void 0!==n[t]&&(e.mandatory=e.mandatory||{},e.mandatory[s(t,i)]=n[t])}))})),t.advanced&&(e.optional=(e.optional||[]).concat(t.advanced)),e},s=function(t,s){if(e.version>=61)return s(t);if((t=JSON.parse(JSON.stringify(t)))&&"object"==typeof t.audio){const e=function(t,e,i){e in t&&!(i in t)&&(t[i]=t[e],delete t[e])};e((t=JSON.parse(JSON.stringify(t))).audio,"autoGainControl","googAutoGainControl"),e(t.audio,"noiseSuppression","googNoiseSuppression"),t.audio=n(t.audio)}if(t&&"object"==typeof t.video){let r=t.video.facingMode;r=r&&("object"==typeof r?r:{ideal:r});const a=e.version<66;if(r&&("user"===r.exact||"environment"===r.exact||"user"===r.ideal||"environment"===r.ideal)&&(!i.mediaDevices.getSupportedConstraints||!i.mediaDevices.getSupportedConstraints().facingMode||a)){let e;if(delete t.video.facingMode,"environment"===r.exact||"environment"===r.ideal?e=["back","rear"]:"user"!==r.exact&&"user"!==r.ideal||(e=["front"]),e)return i.mediaDevices.enumerateDevices().then((i=>{let a=(i=i.filter((t=>"videoinput"===t.kind))).find((t=>e.some((e=>t.label.toLowerCase().includes(e)))));return!a&&i.length&&e.includes("back")&&(a=i[i.length-1]),a&&(t.video.deviceId=r.exact?{exact:a.deviceId}:{ideal:a.deviceId}),t.video=n(t.video),C("chrome: "+JSON.stringify(t)),s(t)}))}t.video=n(t.video)}return C("chrome: "+JSON.stringify(t)),s(t)},r=function(t){return e.version>=64?t:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[t.name]||t.name,message:t.message,constraint:t.constraint||t.constraintName,toString(){return this.name+(this.message&&": ")+this.message}}};if(i.getUserMedia=function(t,e,n){s(t,(t=>{i.webkitGetUserMedia(t,e,(t=>{n&&n(r(t))}))}))}.bind(i),i.mediaDevices.getUserMedia){const t=i.mediaDevices.getUserMedia.bind(i.mediaDevices);i.mediaDevices.getUserMedia=function(e){return s(e,(e=>t(e).then((t=>{if(e.audio&&!t.getAudioTracks().length||e.video&&!t.getVideoTracks().length)throw t.getTracks().forEach((t=>{t.stop()})),new DOMException("","NotFoundError");return t}),(t=>Promise.reject(r(t))))))}}}function v(t,e){t.navigator.mediaDevices&&"getDisplayMedia"in t.navigator.mediaDevices||t.navigator.mediaDevices&&("function"==typeof e?t.navigator.mediaDevices.getDisplayMedia=function(i){return e(i).then((e=>{const n=i.video&&i.video.width,s=i.video&&i.video.height,r=i.video&&i.video.frameRate;return i.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e,maxFrameRate:r||3}},n&&(i.video.mandatory.maxWidth=n),s&&(i.video.mandatory.maxHeight=s),t.navigator.mediaDevices.getUserMedia(i)}))}:console.error("shimGetDisplayMedia: getSourceId argument is not a function"))}function w(t){t.MediaStream=t.MediaStream||t.webkitMediaStream}function k(t){if("object"==typeof t&&t.RTCPeerConnection&&!("ontrack"in t.RTCPeerConnection.prototype)){Object.defineProperty(t.RTCPeerConnection.prototype,"ontrack",{get(){return this._ontrack},set(t){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=t)},enumerable:!0,configurable:!0});const e=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){return this._ontrackpoly||(this._ontrackpoly=e=>{e.stream.addEventListener("addtrack",(i=>{let n;n=t.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find((t=>t.track&&t.track.id===i.track.id)):{track:i.track};const s=new Event("track");s.track=i.track,s.receiver=n,s.transceiver={receiver:n},s.streams=[e.stream],this.dispatchEvent(s)})),e.stream.getTracks().forEach((i=>{let n;n=t.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find((t=>t.track&&t.track.id===i.id)):{track:i};const s=new Event("track");s.track=i,s.receiver=n,s.transceiver={receiver:n},s.streams=[e.stream],this.dispatchEvent(s)}))},this.addEventListener("addstream",this._ontrackpoly)),e.apply(this,arguments)}}else u(t,"track",(t=>(t.transceiver||Object.defineProperty(t,"transceiver",{value:{receiver:t.receiver}}),t)))}function R(t){if("object"==typeof t&&t.RTCPeerConnection&&!("getSenders"in t.RTCPeerConnection.prototype)&&"createDTMFSender"in t.RTCPeerConnection.prototype){const e=function(t,e){return{track:e,get dtmf(){return void 0===this._dtmf&&("audio"===e.kind?this._dtmf=t.createDTMFSender(e):this._dtmf=null),this._dtmf},_pc:t}};if(!t.RTCPeerConnection.prototype.getSenders){t.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};const i=t.RTCPeerConnection.prototype.addTrack;t.RTCPeerConnection.prototype.addTrack=function(t,n){let s=i.apply(this,arguments);return s||(s=e(this,t),this._senders.push(s)),s};const n=t.RTCPeerConnection.prototype.removeTrack;t.RTCPeerConnection.prototype.removeTrack=function(t){n.apply(this,arguments);const e=this._senders.indexOf(t);-1!==e&&this._senders.splice(e,1)}}const i=t.RTCPeerConnection.prototype.addStream;t.RTCPeerConnection.prototype.addStream=function(t){this._senders=this._senders||[],i.apply(this,[t]),t.getTracks().forEach((t=>{this._senders.push(e(this,t))}))};const n=t.RTCPeerConnection.prototype.removeStream;t.RTCPeerConnection.prototype.removeStream=function(t){this._senders=this._senders||[],n.apply(this,[t]),t.getTracks().forEach((t=>{const e=this._senders.find((e=>e.track===t));e&&this._senders.splice(this._senders.indexOf(e),1)}))}}else if("object"==typeof t&&t.RTCPeerConnection&&"getSenders"in t.RTCPeerConnection.prototype&&"createDTMFSender"in t.RTCPeerConnection.prototype&&t.RTCRtpSender&&!("dtmf"in t.RTCRtpSender.prototype)){const e=t.RTCPeerConnection.prototype.getSenders;t.RTCPeerConnection.prototype.getSenders=function(){const t=e.apply(this,[]);return t.forEach((t=>t._pc=this)),t},Object.defineProperty(t.RTCRtpSender.prototype,"dtmf",{get(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}}function T(t){if(!t.RTCPeerConnection)return;const e=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){const[t,i,n]=arguments;if(arguments.length>0&&"function"==typeof t)return e.apply(this,arguments);if(0===e.length&&(0===arguments.length||"function"!=typeof t))return e.apply(this,[]);const s=function(t){const e={};return t.result().forEach((t=>{const i={id:t.id,timestamp:t.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[t.type]||t.type};t.names().forEach((e=>{i[e]=t.stat(e)})),e[i.id]=i})),e},r=function(t){return new Map(Object.keys(t).map((e=>[e,t[e]])))};if(arguments.length>=2){const n=function(t){i(r(s(t)))};return e.apply(this,[n,t])}return new Promise(((t,i)=>{e.apply(this,[function(e){t(r(s(e)))},i])})).then(i,n)}}function z(t){if(!("object"==typeof t&&t.RTCPeerConnection&&t.RTCRtpSender&&t.RTCRtpReceiver))return;if(!("getStats"in t.RTCRtpSender.prototype)){const e=t.RTCPeerConnection.prototype.getSenders;e&&(t.RTCPeerConnection.prototype.getSenders=function(){const t=e.apply(this,[]);return t.forEach((t=>t._pc=this)),t});const i=t.RTCPeerConnection.prototype.addTrack;i&&(t.RTCPeerConnection.prototype.addTrack=function(){const t=i.apply(this,arguments);return t._pc=this,t}),t.RTCRtpSender.prototype.getStats=function(){const t=this;return this._pc.getStats().then((e=>b(e,t.track,!0)))}}if(!("getStats"in t.RTCRtpReceiver.prototype)){const e=t.RTCPeerConnection.prototype.getReceivers;e&&(t.RTCPeerConnection.prototype.getReceivers=function(){const t=e.apply(this,[]);return t.forEach((t=>t._pc=this)),t}),u(t,"track",(t=>(t.receiver._pc=t.srcElement,t))),t.RTCRtpReceiver.prototype.getStats=function(){const t=this;return this._pc.getStats().then((e=>b(e,t.track,!1)))}}if(!("getStats"in t.RTCRtpSender.prototype)||!("getStats"in t.RTCRtpReceiver.prototype))return;const e=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof t.MediaStreamTrack){const t=arguments[0];let e,i,n;return this.getSenders().forEach((i=>{i.track===t&&(e?n=!0:e=i)})),this.getReceivers().forEach((e=>(e.track===t&&(i?n=!0:i=e),e.track===t))),n||e&&i?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):e?e.getStats():i?i.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return e.apply(this,arguments)}}function I(t){t.RTCPeerConnection.prototype.getLocalStreams=function(){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map((t=>this._shimmedLocalStreams[t][0]))};const e=t.RTCPeerConnection.prototype.addTrack;t.RTCPeerConnection.prototype.addTrack=function(t,i){if(!i)return e.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};const n=e.apply(this,arguments);return this._shimmedLocalStreams[i.id]?-1===this._shimmedLocalStreams[i.id].indexOf(n)&&this._shimmedLocalStreams[i.id].push(n):this._shimmedLocalStreams[i.id]=[i,n],n};const i=t.RTCPeerConnection.prototype.addStream;t.RTCPeerConnection.prototype.addStream=function(t){this._shimmedLocalStreams=this._shimmedLocalStreams||{},t.getTracks().forEach((t=>{if(this.getSenders().find((e=>e.track===t)))throw new DOMException("Track already exists.","InvalidAccessError")}));const e=this.getSenders();i.apply(this,arguments);const n=this.getSenders().filter((t=>-1===e.indexOf(t)));this._shimmedLocalStreams[t.id]=[t].concat(n)};const n=t.RTCPeerConnection.prototype.removeStream;t.RTCPeerConnection.prototype.removeStream=function(t){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[t.id],n.apply(this,arguments)};const s=t.RTCPeerConnection.prototype.removeTrack;t.RTCPeerConnection.prototype.removeTrack=function(t){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},t&&Object.keys(this._shimmedLocalStreams).forEach((e=>{const i=this._shimmedLocalStreams[e].indexOf(t);-1!==i&&this._shimmedLocalStreams[e].splice(i,1),1===this._shimmedLocalStreams[e].length&&delete this._shimmedLocalStreams[e]})),s.apply(this,arguments)}}function A(t,e){if(!t.RTCPeerConnection)return;if(t.RTCPeerConnection.prototype.addTrack&&e.version>=65)return I(t);const i=t.RTCPeerConnection.prototype.getLocalStreams;t.RTCPeerConnection.prototype.getLocalStreams=function(){const t=i.apply(this);return this._reverseStreams=this._reverseStreams||{},t.map((t=>this._reverseStreams[t.id]))};const n=t.RTCPeerConnection.prototype.addStream;t.RTCPeerConnection.prototype.addStream=function(e){if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},e.getTracks().forEach((t=>{if(this.getSenders().find((e=>e.track===t)))throw new DOMException("Track already exists.","InvalidAccessError")})),!this._reverseStreams[e.id]){const i=new t.MediaStream(e.getTracks());this._streams[e.id]=i,this._reverseStreams[i.id]=e,e=i}n.apply(this,[e])};const s=t.RTCPeerConnection.prototype.removeStream;function r(t,e){let i=e.sdp;return Object.keys(t._reverseStreams||[]).forEach((e=>{const n=t._reverseStreams[e],s=t._streams[n.id];i=i.replace(new RegExp(s.id,"g"),n.id)})),new RTCSessionDescription({type:e.type,sdp:i})}function a(t,e){let i=e.sdp;return Object.keys(t._reverseStreams||[]).forEach((e=>{const n=t._reverseStreams[e],s=t._streams[n.id];i=i.replace(new RegExp(n.id,"g"),s.id)})),new RTCSessionDescription({type:e.type,sdp:i})}t.RTCPeerConnection.prototype.removeStream=function(t){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},s.apply(this,[this._streams[t.id]||t]),delete this._reverseStreams[this._streams[t.id]?this._streams[t.id].id:t.id],delete this._streams[t.id]},t.RTCPeerConnection.prototype.addTrack=function(e,i){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");const n=[].slice.call(arguments,1);if(1!==n.length||!n[0].getTracks().find((t=>t===e)))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");const s=this.getSenders().find((t=>t.track===e));if(s)throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};const r=this._streams[i.id];if(r)r.addTrack(e),Promise.resolve().then((()=>{this.dispatchEvent(new Event("negotiationneeded"))}));else{const n=new t.MediaStream([e]);this._streams[i.id]=n,this._reverseStreams[n.id]=i,this.addStream(n)}return this.getSenders().find((t=>t.track===e))},["createOffer","createAnswer"].forEach((function(e){const i=t.RTCPeerConnection.prototype[e],n={[e](){const t=arguments;return arguments.length&&"function"==typeof arguments[0]?i.apply(this,[e=>{const i=r(this,e);t[0].apply(null,[i])},e=>{t[1]&&t[1].apply(null,e)},arguments[2]]):i.apply(this,arguments).then((t=>r(this,t)))}};t.RTCPeerConnection.prototype[e]=n[e]}));const o=t.RTCPeerConnection.prototype.setLocalDescription;t.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=a(this,arguments[0]),o.apply(this,arguments)):o.apply(this,arguments)};const l=Object.getOwnPropertyDescriptor(t.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(t.RTCPeerConnection.prototype,"localDescription",{get(){const t=l.get.apply(this);return""===t.type?t:r(this,t)}}),t.RTCPeerConnection.prototype.removeTrack=function(t){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!t._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(t._pc!==this)throw new DOMException("Sender was not created by this connection.","InvalidAccessError");let e;this._streams=this._streams||{},Object.keys(this._streams).forEach((i=>{this._streams[i].getTracks().find((e=>t.track===e))&&(e=this._streams[i])})),e&&(1===e.getTracks().length?this.removeStream(this._reverseStreams[e.id]):e.removeTrack(t.track),this.dispatchEvent(new Event("negotiationneeded")))}}function x(t,e){!t.RTCPeerConnection&&t.webkitRTCPeerConnection&&(t.RTCPeerConnection=t.webkitRTCPeerConnection),t.RTCPeerConnection&&e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(e){const i=t.RTCPeerConnection.prototype[e],n={[e](){return arguments[0]=new("addIceCandidate"===e?t.RTCIceCandidate:t.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};t.RTCPeerConnection.prototype[e]=n[e]}))}function N(t,e){u(t,"negotiationneeded",(t=>{const i=t.target;if(!(e.version<72||i.getConfiguration&&"plan-b"===i.getConfiguration().sdpSemantics)||"stable"===i.signalingState)return t}))}function D(t,e){const i=t&&t.navigator,n=t&&t.MediaStreamTrack;if(i.getUserMedia=function(t,e,n){g("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),i.mediaDevices.getUserMedia(t).then(e,n)},!(e.version>55&&"autoGainControl"in i.mediaDevices.getSupportedConstraints())){const t=function(t,e,i){e in t&&!(i in t)&&(t[i]=t[e],delete t[e])},e=i.mediaDevices.getUserMedia.bind(i.mediaDevices);if(i.mediaDevices.getUserMedia=function(i){return"object"==typeof i&&"object"==typeof i.audio&&(i=JSON.parse(JSON.stringify(i)),t(i.audio,"autoGainControl","mozAutoGainControl"),t(i.audio,"noiseSuppression","mozNoiseSuppression")),e(i)},n&&n.prototype.getSettings){const e=n.prototype.getSettings;n.prototype.getSettings=function(){const i=e.apply(this,arguments);return t(i,"mozAutoGainControl","autoGainControl"),t(i,"mozNoiseSuppression","noiseSuppression"),i}}if(n&&n.prototype.applyConstraints){const e=n.prototype.applyConstraints;n.prototype.applyConstraints=function(i){return"audio"===this.kind&&"object"==typeof i&&(i=JSON.parse(JSON.stringify(i)),t(i,"autoGainControl","mozAutoGainControl"),t(i,"noiseSuppression","mozNoiseSuppression")),e.apply(this,[i])}}}}function E(t,e){t.navigator.mediaDevices&&"getDisplayMedia"in t.navigator.mediaDevices||t.navigator.mediaDevices&&(t.navigator.mediaDevices.getDisplayMedia=function(i){if(!i||!i.video){const t=new DOMException("getDisplayMedia without video constraints is undefined");return t.name="NotFoundError",t.code=8,Promise.reject(t)}return!0===i.video?i.video={mediaSource:e}:i.video.mediaSource=e,t.navigator.mediaDevices.getUserMedia(i)})}function L(t){"object"==typeof t&&t.RTCTrackEvent&&"receiver"in t.RTCTrackEvent.prototype&&!("transceiver"in t.RTCTrackEvent.prototype)&&Object.defineProperty(t.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function _(t,e){if("object"!=typeof t||!t.RTCPeerConnection&&!t.mozRTCPeerConnection)return;!t.RTCPeerConnection&&t.mozRTCPeerConnection&&(t.RTCPeerConnection=t.mozRTCPeerConnection),e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(e){const i=t.RTCPeerConnection.prototype[e],n={[e](){return arguments[0]=new("addIceCandidate"===e?t.RTCIceCandidate:t.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};t.RTCPeerConnection.prototype[e]=n[e]}));const i={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},n=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){const[t,s,r]=arguments;return n.apply(this,[t||null]).then((t=>{if(e.version<53&&!s)try{t.forEach((t=>{t.type=i[t.type]||t.type}))}catch(e){if("TypeError"!==e.name)throw e;t.forEach(((e,n)=>{t.set(n,Object.assign({},e,{type:i[e.type]||e.type}))}))}return t})).then(s,r)}}function F(t){if("object"!=typeof t||!t.RTCPeerConnection||!t.RTCRtpSender)return;if(t.RTCRtpSender&&"getStats"in t.RTCRtpSender.prototype)return;const e=t.RTCPeerConnection.prototype.getSenders;e&&(t.RTCPeerConnection.prototype.getSenders=function(){const t=e.apply(this,[]);return t.forEach((t=>t._pc=this)),t});const i=t.RTCPeerConnection.prototype.addTrack;i&&(t.RTCPeerConnection.prototype.addTrack=function(){const t=i.apply(this,arguments);return t._pc=this,t}),t.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}function O(t){if("object"!=typeof t||!t.RTCPeerConnection||!t.RTCRtpSender)return;if(t.RTCRtpSender&&"getStats"in t.RTCRtpReceiver.prototype)return;const e=t.RTCPeerConnection.prototype.getReceivers;e&&(t.RTCPeerConnection.prototype.getReceivers=function(){const t=e.apply(this,[]);return t.forEach((t=>t._pc=this)),t}),u(t,"track",(t=>(t.receiver._pc=t.srcElement,t))),t.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}function M(t){t.RTCPeerConnection&&!("removeStream"in t.RTCPeerConnection.prototype)&&(t.RTCPeerConnection.prototype.removeStream=function(t){g("removeStream","removeTrack"),this.getSenders().forEach((e=>{e.track&&t.getTracks().includes(e.track)&&this.removeTrack(e)}))})}function P(t){t.DataChannel&&!t.RTCDataChannel&&(t.RTCDataChannel=t.DataChannel)}function j(t){if("object"!=typeof t||!t.RTCPeerConnection)return;const e=t.RTCPeerConnection.prototype.addTransceiver;e&&(t.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];let t=arguments[1]&&arguments[1].sendEncodings;void 0===t&&(t=[]),t=[...t];const i=t.length>0;i&&t.forEach((t=>{if("rid"in t&&!/^[a-z0-9]{0,16}$/i.test(t.rid))throw new TypeError("Invalid RID value provided.");if("scaleResolutionDownBy"in t&&!(parseFloat(t.scaleResolutionDownBy)>=1))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in t&&!(parseFloat(t.maxFramerate)>=0))throw new RangeError("max_framerate must be >= 0.0")}));const n=e.apply(this,arguments);if(i){const{sender:e}=n,i=e.getParameters();(!("encodings"in i)||1===i.encodings.length&&0===Object.keys(i.encodings[0]).length)&&(i.encodings=t,e.sendEncodings=t,this.setParametersPromises.push(e.setParameters(i).then((()=>{delete e.sendEncodings})).catch((()=>{delete e.sendEncodings}))))}return n})}function U(t){if("object"!=typeof t||!t.RTCRtpSender)return;const e=t.RTCRtpSender.prototype.getParameters;e&&(t.RTCRtpSender.prototype.getParameters=function(){const t=e.apply(this,arguments);return"encodings"in t||(t.encodings=[].concat(this.sendEncodings||[{}])),t})}function W(t){if("object"!=typeof t||!t.RTCPeerConnection)return;const e=t.RTCPeerConnection.prototype.createOffer;t.RTCPeerConnection.prototype.createOffer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then((()=>e.apply(this,arguments))).finally((()=>{this.setParametersPromises=[]})):e.apply(this,arguments)}}function $(t){if("object"!=typeof t||!t.RTCPeerConnection)return;const e=t.RTCPeerConnection.prototype.createAnswer;t.RTCPeerConnection.prototype.createAnswer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then((()=>e.apply(this,arguments))).finally((()=>{this.setParametersPromises=[]})):e.apply(this,arguments)}}function B(t){if("object"==typeof t&&t.RTCPeerConnection){if("getLocalStreams"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in t.RTCPeerConnection.prototype)){const e=t.RTCPeerConnection.prototype.addTrack;t.RTCPeerConnection.prototype.addStream=function(t){this._localStreams||(this._localStreams=[]),this._localStreams.includes(t)||this._localStreams.push(t),t.getAudioTracks().forEach((i=>e.call(this,i,t))),t.getVideoTracks().forEach((i=>e.call(this,i,t)))},t.RTCPeerConnection.prototype.addTrack=function(t,...i){return i&&i.forEach((t=>{this._localStreams?this._localStreams.includes(t)||this._localStreams.push(t):this._localStreams=[t]})),e.apply(this,arguments)}}"removeStream"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.removeStream=function(t){this._localStreams||(this._localStreams=[]);const e=this._localStreams.indexOf(t);if(-1===e)return;this._localStreams.splice(e,1);const i=t.getTracks();this.getSenders().forEach((t=>{i.includes(t.track)&&this.removeTrack(t)}))})}}function H(t){if("object"==typeof t&&t.RTCPeerConnection&&("getRemoteStreams"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in t.RTCPeerConnection.prototype))){Object.defineProperty(t.RTCPeerConnection.prototype,"onaddstream",{get(){return this._onaddstream},set(t){this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=t),this.addEventListener("track",this._onaddstreampoly=t=>{t.streams.forEach((t=>{if(this._remoteStreams||(this._remoteStreams=[]),this._remoteStreams.includes(t))return;this._remoteStreams.push(t);const e=new Event("addstream");e.stream=t,this.dispatchEvent(e)}))})}});const e=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){const t=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(e){e.streams.forEach((e=>{if(t._remoteStreams||(t._remoteStreams=[]),t._remoteStreams.indexOf(e)>=0)return;t._remoteStreams.push(e);const i=new Event("addstream");i.stream=e,t.dispatchEvent(i)}))}),e.apply(t,arguments)}}}function Q(t){if("object"!=typeof t||!t.RTCPeerConnection)return;const e=t.RTCPeerConnection.prototype,i=e.createOffer,n=e.createAnswer,s=e.setLocalDescription,r=e.setRemoteDescription,a=e.addIceCandidate;e.createOffer=function(t,e){const n=arguments.length>=2?arguments[2]:arguments[0],s=i.apply(this,[n]);return e?(s.then(t,e),Promise.resolve()):s},e.createAnswer=function(t,e){const i=arguments.length>=2?arguments[2]:arguments[0],s=n.apply(this,[i]);return e?(s.then(t,e),Promise.resolve()):s};let o=function(t,e,i){const n=s.apply(this,[t]);return i?(n.then(e,i),Promise.resolve()):n};e.setLocalDescription=o,o=function(t,e,i){const n=r.apply(this,[t]);return i?(n.then(e,i),Promise.resolve()):n},e.setRemoteDescription=o,o=function(t,e,i){const n=a.apply(this,[t]);return i?(n.then(e,i),Promise.resolve()):n},e.addIceCandidate=o}function J(t){const e=t&&t.navigator;if(e.mediaDevices&&e.mediaDevices.getUserMedia){const t=e.mediaDevices,i=t.getUserMedia.bind(t);e.mediaDevices.getUserMedia=t=>i(V(t))}!e.getUserMedia&&e.mediaDevices&&e.mediaDevices.getUserMedia&&(e.getUserMedia=function(t,i,n){e.mediaDevices.getUserMedia(t).then(i,n)}.bind(e))}function V(t){return t&&void 0!==t.video?Object.assign({},t,{video:f(t.video)}):t}function G(t){if(!t.RTCPeerConnection)return;const e=t.RTCPeerConnection;t.RTCPeerConnection=function(t,i){if(t&&t.iceServers){const e=[];for(let i=0;i<t.iceServers.length;i++){let n=t.iceServers[i];void 0===n.urls&&n.url?(g("RTCIceServer.url","RTCIceServer.urls"),n=JSON.parse(JSON.stringify(n)),n.urls=n.url,delete n.url,e.push(n)):e.push(t.iceServers[i])}t.iceServers=e}return new e(t,i)},t.RTCPeerConnection.prototype=e.prototype,"generateCertificate"in e&&Object.defineProperty(t.RTCPeerConnection,"generateCertificate",{get:()=>e.generateCertificate})}function Z(t){"object"==typeof t&&t.RTCTrackEvent&&"receiver"in t.RTCTrackEvent.prototype&&!("transceiver"in t.RTCTrackEvent.prototype)&&Object.defineProperty(t.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function q(t){const e=t.RTCPeerConnection.prototype.createOffer;t.RTCPeerConnection.prototype.createOffer=function(t){if(t){void 0!==t.offerToReceiveAudio&&(t.offerToReceiveAudio=!!t.offerToReceiveAudio);const e=this.getTransceivers().find((t=>"audio"===t.receiver.track.kind));!1===t.offerToReceiveAudio&&e?"sendrecv"===e.direction?e.setDirection?e.setDirection("sendonly"):e.direction="sendonly":"recvonly"===e.direction&&(e.setDirection?e.setDirection("inactive"):e.direction="inactive"):!0!==t.offerToReceiveAudio||e||this.addTransceiver("audio",{direction:"recvonly"}),void 0!==t.offerToReceiveVideo&&(t.offerToReceiveVideo=!!t.offerToReceiveVideo);const i=this.getTransceivers().find((t=>"video"===t.receiver.track.kind));!1===t.offerToReceiveVideo&&i?"sendrecv"===i.direction?i.setDirection?i.setDirection("sendonly"):i.direction="sendonly":"recvonly"===i.direction&&(i.setDirection?i.setDirection("inactive"):i.direction="inactive"):!0!==t.offerToReceiveVideo||i||this.addTransceiver("video",{direction:"recvonly"})}return e.apply(this,arguments)}}function K(t){"object"!=typeof t||t.AudioContext||(t.AudioContext=t.webkitAudioContext)}var X=i(57539),Y=i.n(X);function tt(t){if(!t.RTCIceCandidate||t.RTCIceCandidate&&"foundation"in t.RTCIceCandidate.prototype)return;const e=t.RTCIceCandidate;t.RTCIceCandidate=function(t){if("object"==typeof t&&t.candidate&&0===t.candidate.indexOf("a=")&&((t=JSON.parse(JSON.stringify(t))).candidate=t.candidate.substring(2)),t.candidate&&t.candidate.length){const i=new e(t),n=Y().parseCandidate(t.candidate);for(const t in n)t in i||Object.defineProperty(i,t,{value:n[t]});return i.toJSON=function(){return{candidate:i.candidate,sdpMid:i.sdpMid,sdpMLineIndex:i.sdpMLineIndex,usernameFragment:i.usernameFragment}},i}return new e(t)},t.RTCIceCandidate.prototype=e.prototype,u(t,"icecandidate",(e=>(e.candidate&&Object.defineProperty(e,"candidate",{value:new t.RTCIceCandidate(e.candidate),writable:"false"}),e)))}function et(t){!t.RTCIceCandidate||t.RTCIceCandidate&&"relayProtocol"in t.RTCIceCandidate.prototype||u(t,"icecandidate",(t=>{if(t.candidate){const e=Y().parseCandidate(t.candidate.candidate);"relay"===e.type&&(t.candidate.relayProtocol={0:"tls",1:"tcp",2:"udp"}[e.priority>>24])}return t}))}function it(t,e){if(!t.RTCPeerConnection)return;"sctp"in t.RTCPeerConnection.prototype||Object.defineProperty(t.RTCPeerConnection.prototype,"sctp",{get(){return void 0===this._sctp?null:this._sctp}});const i=function(t){if(!t||!t.sdp)return!1;const e=Y().splitSections(t.sdp);return e.shift(),e.some((t=>{const e=Y().parseMLine(t);return e&&"application"===e.kind&&-1!==e.protocol.indexOf("SCTP")}))},n=function(t){const e=t.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(null===e||e.length<2)return-1;const i=parseInt(e[1],10);return i!=i?-1:i},s=function(t){let i=65536;return"firefox"===e.browser&&(i=e.version<57?-1===t?16384:2147483637:e.version<60?57===e.version?65535:65536:2147483637),i},r=function(t,i){let n=65536;"firefox"===e.browser&&57===e.version&&(n=65535);const s=Y().matchPrefix(t.sdp,"a=max-message-size:");return s.length>0?n=parseInt(s[0].substring(19),10):"firefox"===e.browser&&-1!==i&&(n=2147483637),n},a=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,"chrome"===e.browser&&e.version>=76){const{sdpSemantics:t}=this.getConfiguration();"plan-b"===t&&Object.defineProperty(this,"sctp",{get(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0})}if(i(arguments[0])){const t=n(arguments[0]),e=s(t),i=r(arguments[0],t);let a;a=0===e&&0===i?Number.POSITIVE_INFINITY:0===e||0===i?Math.max(e,i):Math.min(e,i);const o={};Object.defineProperty(o,"maxMessageSize",{get:()=>a}),this._sctp=o}return a.apply(this,arguments)}}function nt(t){if(!t.RTCPeerConnection||!("createDataChannel"in t.RTCPeerConnection.prototype))return;function e(t,e){const i=t.send;t.send=function(){const n=arguments[0],s=n.length||n.size||n.byteLength;if("open"===t.readyState&&e.sctp&&s>e.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+e.sctp.maxMessageSize+" bytes)");return i.apply(t,arguments)}}const i=t.RTCPeerConnection.prototype.createDataChannel;t.RTCPeerConnection.prototype.createDataChannel=function(){const t=i.apply(this,arguments);return e(t,this),t},u(t,"datachannel",(t=>(e(t.channel,t.target),t)))}function st(t){if(!t.RTCPeerConnection||"connectionState"in t.RTCPeerConnection.prototype)return;const e=t.RTCPeerConnection.prototype;Object.defineProperty(e,"connectionState",{get(){return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(e,"onconnectionstatechange",{get(){return this._onconnectionstatechange||null},set(t){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),t&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=t)},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach((t=>{const i=e[t];e[t]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=t=>{const e=t.target;if(e._lastConnectionState!==e.connectionState){e._lastConnectionState=e.connectionState;const i=new Event("connectionstatechange",t);e.dispatchEvent(i)}return t},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),i.apply(this,arguments)}}))}function rt(t,e){if(!t.RTCPeerConnection)return;if("chrome"===e.browser&&e.version>=71)return;if("safari"===e.browser&&e.version>=605)return;const i=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(e){if(e&&e.sdp&&-1!==e.sdp.indexOf("\na=extmap-allow-mixed")){const i=e.sdp.split("\n").filter((t=>"a=extmap-allow-mixed"!==t.trim())).join("\n");t.RTCSessionDescription&&e instanceof t.RTCSessionDescription?arguments[0]=new t.RTCSessionDescription({type:e.type,sdp:i}):e.sdp=i}return i.apply(this,arguments)}}function at(t,e){if(!t.RTCPeerConnection||!t.RTCPeerConnection.prototype)return;const i=t.RTCPeerConnection.prototype.addIceCandidate;i&&0!==i.length&&(t.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?("chrome"===e.browser&&e.version<78||"firefox"===e.browser&&e.version<68||"safari"===e.browser)&&arguments[0]&&""===arguments[0].candidate?Promise.resolve():i.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())})}function ot(t,e){if(!t.RTCPeerConnection||!t.RTCPeerConnection.prototype)return;const i=t.RTCPeerConnection.prototype.setLocalDescription;i&&0!==i.length&&(t.RTCPeerConnection.prototype.setLocalDescription=function(){let t=arguments[0]||{};if("object"!=typeof t||t.type&&t.sdp)return i.apply(this,arguments);if(t={type:t.type,sdp:t.sdp},!t.type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":t.type="offer";break;default:t.type="answer"}if(t.sdp||"offer"!==t.type&&"answer"!==t.type)return i.apply(this,[t]);const e="offer"===t.type?this.createOffer:this.createAnswer;return e.apply(this).then((t=>i.apply(this,[t])))})}const lt=function({window:t}={},e={shimChrome:!0,shimFirefox:!0,shimSafari:!0}){const i=d,o=function(t){const e={browser:null,version:null};if(void 0===t||!t.navigator||!t.navigator.userAgent)return e.browser="Not a browser.",e;const{navigator:i}=t;if(i.mozGetUserMedia)e.browser="firefox",e.version=h(i.userAgent,/Firefox\/(\d+)\./,1);else if(i.webkitGetUserMedia||!1===t.isSecureContext&&t.webkitRTCPeerConnection)e.browser="chrome",e.version=h(i.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else{if(!t.RTCPeerConnection||!i.userAgent.match(/AppleWebKit\/(\d+)\./))return e.browser="Not a supported browser.",e;e.browser="safari",e.version=h(i.userAgent,/AppleWebKit\/(\d+)\./,1),e.supportsUnifiedPlan=t.RTCRtpTransceiver&&"currentDirection"in t.RTCRtpTransceiver.prototype}return e}(t),l={browserDetails:o,commonShim:a,extractVersion:h,disableLog:c,disableWarnings:p,sdp:X};switch(o.browser){case"chrome":if(!n||!x||!e.shimChrome)return i("Chrome shim is not included in this adapter release."),l;if(null===o.version)return i("Chrome shim can not determine version, not shimming."),l;i("adapter.js shimming chrome."),l.browserShim=n,at(t,o),ot(t),S(t,o),w(t),x(t,o),k(t),A(t,o),R(t),T(t),z(t),N(t,o),tt(t),et(t),st(t),it(t,o),nt(t),rt(t,o);break;case"firefox":if(!s||!_||!e.shimFirefox)return i("Firefox shim is not included in this adapter release."),l;i("adapter.js shimming firefox."),l.browserShim=s,at(t,o),ot(t),D(t,o),_(t,o),L(t),M(t),F(t),O(t),P(t),j(t),U(t),W(t),$(t),tt(t),st(t),it(t,o),nt(t);break;case"safari":if(!r||!e.shimSafari)return i("Safari shim is not included in this adapter release."),l;i("adapter.js shimming safari."),l.browserShim=r,at(t,o),ot(t),G(t),q(t),Q(t),B(t),H(t),Z(t),J(t),K(t),tt(t),et(t),it(t,o),nt(t),rt(t,o);break;default:i("Unsupported browser!")}return l}({window:"undefined"==typeof window?void 0:window}),ht=lt}}]);